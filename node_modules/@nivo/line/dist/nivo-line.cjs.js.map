{"version":3,"file":"nivo-line.cjs.js","sources":["../src/PointTooltip.tsx","../src/defaults.ts","../src/SliceTooltip.tsx","../src/hooks.ts","../src/Areas.tsx","../src/LinesItem.tsx","../src/Lines.tsx","../src/SlicesItem.tsx","../src/Slices.tsx","../src/Points.tsx","../src/Mesh.tsx","../src/Line.tsx","../src/LineCanvas.tsx","../src/ResponsiveLineCanvas.tsx","../src/ResponsiveLine.tsx","../src/types.ts"],"sourcesContent":["import { memo } from 'react'\nimport { BasicTooltip } from '@nivo/tooltip'\nimport { LineSeries, PointTooltipProps } from './types'\n\nexport const NonMemoizedPointTooltip = <Series extends LineSeries>({\n    point,\n}: PointTooltipProps<Series>) => {\n    return (\n        <BasicTooltip\n            id={\n                <span>\n                    x: <strong>{point.data.xFormatted}</strong>, y:{' '}\n                    <strong>{point.data.yFormatted}</strong>\n                </span>\n            }\n            enableChip={true}\n            color={point.seriesColor}\n        />\n    )\n}\n\nexport const PointTooltip = memo(NonMemoizedPointTooltip)\n","import {\n    CommonLineProps,\n    LineSvgPropsWithDefaults,\n    LineCanvasPropsWithDefaults,\n    DefaultSeries,\n    LineLayerId,\n} from './types'\nimport { PointTooltip } from './PointTooltip'\nimport { SliceTooltip } from './SliceTooltip'\n\nexport const commonDefaultProps: Omit<\n    CommonLineProps<DefaultSeries>,\n    | 'data'\n    | 'xFormat'\n    | 'yFormat'\n    | 'layers'\n    | 'width'\n    | 'height'\n    | 'margin'\n    | 'theme'\n    | 'pointSymbol'\n    | 'gridXValues'\n    | 'gridYValues'\n    | 'axisTop'\n    | 'axisRight'\n    | 'onMouseEnter'\n    | 'onMouseMove'\n    | 'onMouseLeave'\n    | 'onMouseDown'\n    | 'onMouseUp'\n    | 'onClick'\n    | 'onDoubleClick'\n    | 'onTouchStart'\n    | 'onTouchMove'\n    | 'onTouchEnd'\n> & {\n    layers: LineLayerId[]\n} = {\n    xScale: {\n        type: 'point',\n    },\n    yScale: {\n        type: 'linear',\n        min: 0,\n        max: 'auto',\n    },\n    curve: 'linear',\n    colors: { scheme: 'nivo' },\n    lineWidth: 2,\n    layers: [\n        'grid',\n        'markers',\n        'axes',\n        'areas',\n        'crosshair',\n        'lines',\n        'points',\n        'slices',\n        'mesh',\n        'legends',\n    ],\n    enablePoints: true,\n    pointSize: 6,\n    pointColor: { from: 'series.color' },\n    pointBorderWidth: 0,\n    pointBorderColor: { theme: 'background' },\n    enableArea: false,\n    areaBaselineValue: 0,\n    areaOpacity: 0.2,\n    enableGridX: true,\n    enableGridY: true,\n    legends: [],\n    isInteractive: true,\n    tooltip: PointTooltip,\n    sliceTooltip: SliceTooltip,\n    debugMesh: false,\n    renderWrapper: true,\n}\n\nexport const svgDefaultProps: Omit<\n    LineSvgPropsWithDefaults<DefaultSeries>,\n    'data' | 'width' | 'height' | 'margin' | 'theme'\n> = {\n    ...commonDefaultProps,\n    defs: [],\n    fill: [],\n    enablePointLabel: false,\n    pointLabel: 'data.yFormatted',\n    areaBlendMode: 'normal',\n    axisBottom: {},\n    axisLeft: {},\n    useMesh: false,\n    enableSlices: false,\n    debugSlices: false,\n    enableCrosshair: true,\n    crosshairType: 'bottom-left',\n    enableTouchCrosshair: false,\n    initialHiddenIds: [],\n    animate: true,\n    motionConfig: 'gentle',\n    role: 'img',\n    isFocusable: false,\n}\n\nexport const canvasDefaultProps: Omit<\n    LineCanvasPropsWithDefaults<DefaultSeries>,\n    'data' | 'width' | 'height' | 'margin' | 'theme'\n> = {\n    ...commonDefaultProps,\n    pixelRatio: typeof window !== 'undefined' ? (window.devicePixelRatio ?? 1) : 1,\n    axisBottom: {},\n    axisLeft: {},\n}\n","import { memo } from 'react'\nimport { useTheme } from '@nivo/theming'\nimport { Chip, TableTooltip } from '@nivo/tooltip'\nimport { LineSeries, SliceTooltipProps } from './types'\n\nexport const NonMemoizedSliceTooltip = <Series extends LineSeries>({\n    slice,\n    axis,\n}: SliceTooltipProps<Series>) => {\n    const theme = useTheme()\n    const otherAxis = axis === 'x' ? 'y' : 'x'\n\n    return (\n        <TableTooltip\n            rows={slice.points.map(point => [\n                <Chip key=\"chip\" color={point.seriesColor} style={theme.tooltip.chip} />,\n                point.seriesId,\n                <span key=\"value\" style={theme.tooltip.tableCellValue}>\n                    {point.data[`${otherAxis}Formatted`]}\n                </span>,\n            ])}\n        />\n    )\n}\n\nexport const SliceTooltip = memo(NonMemoizedSliceTooltip)\n","import { useCallback, useMemo, useState } from 'react'\nimport { area, line } from 'd3-shape'\nimport uniqueId from 'lodash/uniqueId.js'\nimport { curveFromProp, useValueFormatter } from '@nivo/core'\nimport { useTheme } from '@nivo/theming'\nimport {\n    useOrdinalColorScale,\n    useInheritedColor,\n    OrdinalColorScaleConfig,\n    InheritedColorConfig,\n} from '@nivo/colors'\nimport { computeXYScalesForSeries } from '@nivo/scales'\nimport { commonDefaultProps, svgDefaultProps } from './defaults'\nimport {\n    LineSeries,\n    CommonLineProps,\n    DataProps,\n    InferX,\n    InferY,\n    InferSeriesId,\n    LineSvgProps,\n    LineGenerator,\n    AreaGenerator,\n    AllowedValue,\n    ComputedSeries,\n    Point,\n    SliceData,\n    PointColorContext,\n} from './types'\n\nexport function useLineGenerator(curve: CommonLineProps<LineSeries>['curve']): LineGenerator {\n    return useMemo(() => {\n        return line<{\n            x: number\n            y: number\n        }>()\n            .defined(d => d.x !== null && d.y !== null)\n            .x(d => d.x)\n            .y(d => d.y)\n            .curve(curveFromProp(curve))\n    }, [curve])\n}\n\nexport function useAreaGenerator<Y extends AllowedValue>({\n    curve,\n    yScale,\n    areaBaselineValue,\n}: {\n    curve: CommonLineProps<LineSeries>['curve']\n    yScale: (y: Y) => number\n    areaBaselineValue: Y\n}): AreaGenerator {\n    return useMemo(() => {\n        return area<{\n            x: number\n            y: number\n        }>()\n            .defined(d => d.x !== null && d.y !== null)\n            .x(d => d.x)\n            .y1(d => d.y)\n            .curve(curveFromProp(curve))\n            .y0(yScale(areaBaselineValue))\n    }, [curve, yScale, areaBaselineValue])\n}\n\nfunction usePoints<Series extends LineSeries>({\n    series,\n    getPointColor,\n    getPointBorderColor,\n    formatX,\n    formatY,\n}: {\n    series: ComputedSeries<Series>[]\n    getPointColor: (context: PointColorContext<Series>) => string\n    getPointBorderColor: (point: Omit<Point<Series>, 'borderColor'>) => string\n    formatX: (x: InferX<Series>) => string\n    formatY: (y: InferY<Series>) => string\n}) {\n    return useMemo(() => {\n        return series.reduce((acc, seriesItem, seriesIndex) => {\n            return [\n                ...acc,\n                ...seriesItem.data\n                    .filter(datum => datum.position.x !== null && datum.position.y !== null)\n                    .map((datum, indexInSeries) => {\n                        const point: Omit<Point<Series>, 'color' | 'borderColor'> & {\n                            color?: string\n                            borderColor?: string\n                        } = {\n                            id: `${seriesItem.id}.${indexInSeries}`,\n                            indexInSeries,\n                            absIndex: acc.length + indexInSeries,\n                            seriesIndex,\n                            seriesId: seriesItem.id,\n                            seriesColor: seriesItem.color,\n                            x: datum.position.x,\n                            y: datum.position.y,\n                            data: {\n                                ...datum.data,\n                                xFormatted: formatX(datum.data.x as InferX<Series>),\n                                yFormatted: formatY(datum.data.y as InferY<Series>),\n                            },\n                        }\n                        point.color = getPointColor({\n                            series: seriesItem,\n                            point: point as Omit<Point<Series>, 'color' | 'borderColor'>,\n                        })\n                        point.borderColor = getPointBorderColor(\n                            point as Omit<Point<Series>, 'borderColor'>\n                        )\n\n                        return point as Point<Series>\n                    }),\n            ]\n        }, [] as Point<Series>[])\n    }, [series, getPointColor, getPointBorderColor, formatX, formatY])\n}\n\nexport const useSlices = <Series extends LineSeries>({\n    componentId,\n    enableSlices,\n    points,\n    width,\n    height,\n}: {\n    componentId: string\n    enableSlices: Exclude<LineSvgProps<Series>['enableSlices'], undefined>\n    points: Point<Series>[]\n    width: number\n    height: number\n}) => {\n    return useMemo(() => {\n        if (enableSlices === 'x') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.x)) map.set(point.x, [point])\n                else map.get(point.x).push(point)\n            })\n\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([x, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let x0\n                    if (!prevSlice) x0 = x\n                    else x0 = x - (x - prevSlice[0]) / 2\n\n                    let sliceWidth\n                    if (!nextSlice) sliceWidth = width - x0\n                    else sliceWidth = x - x0 + (nextSlice[0] - x) / 2\n\n                    return {\n                        id: `slice:${componentId}:${x}`,\n                        x0,\n                        x,\n                        y0: 0,\n                        y: 0,\n                        width: sliceWidth,\n                        height,\n                        points: slicePoints.reverse(),\n                    } as SliceData<Series>\n                })\n        } else if (enableSlices === 'y') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.y)) map.set(point.y, [point])\n                else map.get(point.y).push(point)\n            })\n\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([y, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let y0\n                    if (!prevSlice) y0 = y\n                    else y0 = y - (y - prevSlice[0]) / 2\n\n                    let sliceHeight\n                    if (!nextSlice) sliceHeight = height - y0\n                    else sliceHeight = y - y0 + (nextSlice[0] - y) / 2\n\n                    return {\n                        id: y,\n                        x0: 0,\n                        x: 0,\n                        y0,\n                        y,\n                        width,\n                        height: sliceHeight,\n                        points: slicePoints.reverse(),\n                    } as SliceData<Series>\n                })\n        }\n\n        return []\n    }, [componentId, enableSlices, height, points, width])\n}\n\nexport const LINE_UNIQUE_ID_PREFIX = 'line'\n\nexport const useLine = <Series extends LineSeries>({\n    data,\n    xScale: xScaleSpec = commonDefaultProps.xScale,\n    xFormat,\n    yScale: yScaleSpec = commonDefaultProps.yScale,\n    yFormat,\n    width,\n    height,\n    colors = commonDefaultProps.colors as OrdinalColorScaleConfig<Series>,\n    curve = commonDefaultProps.curve,\n    areaBaselineValue = commonDefaultProps.areaBaselineValue as InferY<Series>,\n    pointColor = commonDefaultProps.pointColor as InheritedColorConfig<PointColorContext<Series>>,\n    pointBorderColor = commonDefaultProps.pointBorderColor as InheritedColorConfig<\n        Omit<Point<Series>, 'borderColor'>\n    >,\n    enableSlices = svgDefaultProps.enableSlices as Exclude<\n        LineSvgProps<Series>['enableSlices'],\n        undefined\n    >,\n    initialHiddenIds = svgDefaultProps.initialHiddenIds as InferSeriesId<Series>[],\n}: DataProps<Series> &\n    Pick<\n        CommonLineProps<Series>,\n        | 'xScale'\n        | 'yScale'\n        | 'colors'\n        | 'curve'\n        | 'areaBaselineValue'\n        | 'pointColor'\n        | 'pointBorderColor'\n    > & {\n        xFormat?: CommonLineProps<Series>['xFormat']\n        yFormat?: CommonLineProps<Series>['yFormat']\n    } & Pick<LineSvgProps<Series>, 'enableSlices' | 'initialHiddenIds'> & {\n        width: number\n        height: number\n    }): {\n    legendData: {\n        id: InferSeriesId<Series>\n        label: string\n        color: string\n        hidden: boolean\n    }[]\n    toggleSeries: (id: InferSeriesId<Series>) => void\n    lineGenerator: LineGenerator\n    areaGenerator: AreaGenerator\n    getColor: (series: Series) => string\n    series: ComputedSeries<Series>[]\n    xScale: (x: InferX<Series>) => number\n    yScale: (y: InferY<Series>) => number\n    slices: SliceData<Series>[]\n    points: Point<Series>[]\n} => {\n    const [componentId] = useState(uniqueId(LINE_UNIQUE_ID_PREFIX))\n    const formatX = useValueFormatter(xFormat)\n    const formatY = useValueFormatter(yFormat)\n    const getColor = useOrdinalColorScale(colors, 'id')\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n    const [hiddenIds, setHiddenIds] = useState(initialHiddenIds ?? [])\n\n    const {\n        xScale,\n        yScale,\n        series: rawSeries,\n    } = useMemo(\n        () =>\n            computeXYScalesForSeries<Series, Series['data'][number]>(\n                data.filter(item => hiddenIds.indexOf(item.id as InferSeriesId<Series>) === -1),\n                xScaleSpec,\n                yScaleSpec,\n                width,\n                height\n            ),\n        [data, hiddenIds, xScaleSpec, yScaleSpec, width, height]\n    )\n\n    const { legendData, series } = useMemo(() => {\n        const dataWithColor = data.map(seriesItem => ({\n            id: seriesItem.id as InferSeriesId<Series>,\n            label: `${seriesItem.id}`,\n            color: getColor(seriesItem),\n        }))\n\n        const series = dataWithColor\n            .map(datum => ({\n                ...rawSeries.find(seriesItem => seriesItem.id === datum.id)!,\n                color: datum.color,\n            }))\n            .filter(item => Boolean(item.id)) as unknown as ComputedSeries<Series>[]\n\n        const legendData = dataWithColor\n            .map(item => ({\n                ...item,\n                hidden: !series.find(seriesItem => seriesItem.id === item.id),\n            }))\n            .reverse()\n\n        return { legendData, series }\n    }, [data, rawSeries, getColor])\n\n    const toggleSeries = useCallback((id: InferSeriesId<Series>) => {\n        setHiddenIds(state =>\n            state.indexOf(id) > -1 ? state.filter(item => item !== id) : [...state, id]\n        )\n    }, [])\n\n    const points = usePoints<Series>({\n        series,\n        getPointColor,\n        getPointBorderColor,\n        formatX,\n        formatY,\n    })\n\n    const slices = useSlices<Series>({\n        componentId,\n        enableSlices,\n        points,\n        width,\n        height,\n    })\n\n    const lineGenerator = useLineGenerator(curve)\n    const areaGenerator = useAreaGenerator<InferY<Series>>({\n        curve,\n        yScale: yScale as (y: InferY<Series>) => number,\n        areaBaselineValue,\n    })\n\n    return {\n        legendData,\n        toggleSeries,\n        lineGenerator,\n        areaGenerator,\n        getColor,\n        series,\n        xScale: xScale as (x: InferX<Series>) => number,\n        yScale: yScale as (y: InferY<Series>) => number,\n        slices,\n        points,\n    }\n}\n","import { memo } from 'react'\nimport { useSpring, animated } from '@react-spring/web'\nimport { CssMixBlendMode, useAnimatedPath, useMotionConfig } from '@nivo/core'\nimport { LineSeries, ComputedSeries, AreaGenerator } from './types'\n\nconst AreaPath = ({\n    areaBlendMode,\n    areaOpacity,\n    color,\n    fill,\n    path,\n}: {\n    areaBlendMode: CssMixBlendMode\n    areaOpacity: number\n    color: string\n    fill?: string\n    path: string\n}) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedPath = useAnimatedPath(path)\n    const animatedProps = useSpring({\n        color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            fill={fill ? fill : animatedProps.color}\n            fillOpacity={areaOpacity}\n            strokeWidth={0}\n            style={{\n                mixBlendMode: areaBlendMode,\n            }}\n        />\n    )\n}\n\nconst NonMemoizedAreas = <Series extends LineSeries>({\n    areaGenerator,\n    areaOpacity,\n    areaBlendMode,\n    series,\n}: {\n    areaGenerator: AreaGenerator\n    areaOpacity: number\n    areaBlendMode: CssMixBlendMode\n    series: readonly ComputedSeries<Series>[]\n}) => {\n    const reversedSeries = series.slice(0).reverse()\n\n    return (\n        <g>\n            {reversedSeries.map(seriesItem => (\n                <AreaPath\n                    key={`${seriesItem.id}`}\n                    path={areaGenerator(seriesItem.data.map(d => d.position))!}\n                    {...{ areaOpacity, areaBlendMode, ...seriesItem }}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport const Areas = memo(NonMemoizedAreas) as typeof NonMemoizedAreas\n","import { memo, useMemo } from 'react'\nimport { animated } from '@react-spring/web'\nimport { useAnimatedPath } from '@nivo/core'\nimport { LineGenerator } from './types'\n\nexport const NonMemoizedLinesItem = ({\n    lineGenerator,\n    points,\n    color,\n    thickness,\n}: {\n    lineGenerator: LineGenerator\n    points: { x: number; y: number }[]\n    color: string\n    thickness: number\n}) => {\n    const path = useMemo(() => lineGenerator(points), [lineGenerator, points])\n    const animatedPath = useAnimatedPath(path!)\n\n    return <animated.path d={animatedPath} fill=\"none\" strokeWidth={thickness} stroke={color} />\n}\n\nexport const LinesItem = memo(NonMemoizedLinesItem) as typeof NonMemoizedLinesItem\n","import { memo } from 'react'\nimport { LineSeries, ComputedSeries, LineGenerator } from './types'\nimport { LinesItem } from './LinesItem'\n\nexport const NonMemoizedLines = <Series extends LineSeries>({\n    series,\n    lineGenerator,\n    lineWidth,\n}: {\n    series: readonly ComputedSeries<Series>[]\n    lineGenerator: LineGenerator\n    lineWidth: number\n}) => {\n    return (\n        <>\n            {series\n                .slice(0)\n                .reverse()\n                .map(({ id, data, color }) => (\n                    <LinesItem\n                        key={id}\n                        points={data.map(d => d.position)}\n                        lineGenerator={lineGenerator}\n                        color={color}\n                        thickness={lineWidth}\n                    />\n                ))}\n        </>\n    )\n}\n\nexport const Lines = memo(NonMemoizedLines) as typeof NonMemoizedLines\n","import { createElement, memo, useCallback, MouseEvent, TouchEvent } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\nimport { LineSeries, SliceData, CommonLineProps, LineSvgProps } from './types'\n\nexport const NonMemoizedSlicesItem = <Series extends LineSeries>({\n    slice,\n    slices,\n    axis,\n    debug,\n    tooltip,\n    isCurrent,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}: {\n    slice: SliceData<Series>\n    slices: readonly SliceData<Series>[]\n    axis: Exclude<LineSvgProps<Series>['enableSlices'], undefined | false>\n    debug: boolean\n    tooltip: CommonLineProps<Series>['sliceTooltip']\n    isCurrent: boolean\n    setCurrent: (slice: SliceData<Series> | null) => void\n    onMouseEnter?: CommonLineProps<Series>['onMouseEnter']\n    onMouseMove?: CommonLineProps<Series>['onMouseMove']\n    onMouseLeave?: CommonLineProps<Series>['onMouseLeave']\n    onMouseDown?: CommonLineProps<Series>['onMouseDown']\n    onMouseUp?: CommonLineProps<Series>['onMouseUp']\n    onClick?: CommonLineProps<Series>['onClick']\n    onDoubleClick?: CommonLineProps<Series>['onDoubleClick']\n    onTouchStart?: CommonLineProps<Series>['onTouchStart']\n    onTouchMove?: CommonLineProps<Series>['onTouchMove']\n    onTouchEnd?: CommonLineProps<Series>['onTouchEnd']\n}) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onMouseEnter?.(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, setCurrent, onMouseEnter]\n    )\n\n    const handleMouseMove = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            onMouseMove?.(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            hideTooltip()\n            setCurrent(null)\n            onMouseLeave?.(slice, event)\n        },\n        [hideTooltip, setCurrent, onMouseLeave, slice]\n    )\n\n    const handleMouseDown = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onMouseDown?.(slice, event)\n        },\n        [slice, onMouseDown]\n    )\n\n    const handleMouseUp = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onMouseUp?.(slice, event)\n        },\n        [slice, onMouseUp]\n    )\n\n    const handleClick = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onClick?.(slice, event)\n        },\n        [slice, onClick]\n    )\n\n    const handleDoubleClick = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onDoubleClick?.(slice, event)\n        },\n        [slice, onDoubleClick]\n    )\n\n    const handeOnTouchStart = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onTouchStart?.(slice, event)\n        },\n        [axis, onTouchStart, setCurrent, showTooltipFromEvent, slice, tooltip]\n    )\n\n    const handeOnTouchMove = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            // This event will be locked to the element that was touched originally\n            // We find the element that is currently being \"hovered over\" by getting the element at the touch point\n            const touchPoint = event.touches[0]\n            const touchingElement = document.elementFromPoint(\n                touchPoint.clientX,\n                touchPoint.clientY\n            )\n            // Is this a nivo ref?\n            const touchingSliceId = touchingElement?.getAttribute('data-ref')\n            if (touchingSliceId) {\n                // Is this a slice for this graph?\n                const slice = slices.find(slice => slice.id === touchingSliceId)\n                if (slice) {\n                    showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n                    setCurrent(slice)\n                }\n            }\n\n            // Note here, this will pass the original slice, not the one we found\n            // But this can be found with document.elementFromPoint()\n            onTouchMove?.(slice, event)\n        },\n        [axis, onTouchMove, setCurrent, showTooltipFromEvent, slice, slices, tooltip]\n    )\n\n    const handleOnTouchEnd = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            hideTooltip()\n            setCurrent(null)\n            onTouchEnd?.(slice, event)\n        },\n        [hideTooltip, setCurrent, onTouchEnd, slice]\n    )\n\n    return (\n        <rect\n            x={slice.x0}\n            y={slice.y0}\n            width={slice.width}\n            height={slice.height}\n            stroke=\"red\"\n            strokeWidth={debug ? 1 : 0}\n            strokeOpacity={0.75}\n            fill=\"red\"\n            fillOpacity={isCurrent && debug ? 0.35 : 0}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onMouseDown={handleMouseDown}\n            onMouseUp={handleMouseUp}\n            onClick={handleClick}\n            onDoubleClick={handleDoubleClick}\n            onTouchStart={handeOnTouchStart}\n            onTouchMove={handeOnTouchMove}\n            onTouchEnd={handleOnTouchEnd}\n            data-ref={slice.id}\n        />\n    )\n}\n\nexport const SlicesItem = memo(NonMemoizedSlicesItem) as typeof NonMemoizedSlicesItem\n","import { memo } from 'react'\nimport { SlicesItem } from './SlicesItem'\nimport { LineSeries, SliceData, CommonLineProps, LineSvgProps } from './types'\n\nexport const NonMemoizedSlices = <Series extends LineSeries>({\n    slices,\n    axis,\n    debug,\n    tooltip,\n    current,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}: {\n    slices: readonly SliceData<Series>[]\n    axis: Exclude<LineSvgProps<Series>['enableSlices'], undefined | false>\n    debug: boolean\n    tooltip: CommonLineProps<Series>['sliceTooltip']\n    current: SliceData<Series> | null\n    setCurrent: (slice: SliceData<Series> | null) => void\n    onMouseEnter?: CommonLineProps<Series>['onMouseEnter']\n    onMouseMove?: CommonLineProps<Series>['onMouseMove']\n    onMouseLeave?: CommonLineProps<Series>['onMouseLeave']\n    onMouseDown?: CommonLineProps<Series>['onMouseDown']\n    onMouseUp?: CommonLineProps<Series>['onMouseUp']\n    onClick?: CommonLineProps<Series>['onClick']\n    onDoubleClick?: CommonLineProps<Series>['onDoubleClick']\n    onTouchStart?: CommonLineProps<Series>['onTouchStart']\n    onTouchMove?: CommonLineProps<Series>['onTouchMove']\n    onTouchEnd?: CommonLineProps<Series>['onTouchEnd']\n}) => {\n    return (\n        <>\n            {slices.map(slice => (\n                <SlicesItem<Series>\n                    key={slice.id}\n                    slice={slice}\n                    slices={slices}\n                    axis={axis}\n                    debug={debug}\n                    tooltip={tooltip}\n                    setCurrent={setCurrent}\n                    isCurrent={current !== null && current.id === slice.id}\n                    onMouseEnter={onMouseEnter}\n                    onMouseMove={onMouseMove}\n                    onMouseLeave={onMouseLeave}\n                    onMouseDown={onMouseDown}\n                    onMouseUp={onMouseUp}\n                    onClick={onClick}\n                    onDoubleClick={onDoubleClick}\n                    onTouchStart={onTouchStart}\n                    onTouchMove={onTouchMove}\n                    onTouchEnd={onTouchEnd}\n                />\n            ))}\n        </>\n    )\n}\n\nexport const Slices = memo(NonMemoizedSlices) as typeof NonMemoizedSlices\n","import { createElement, memo } from 'react'\n// @ts-expect-error no types\nimport { getLabelGenerator } from '@nivo/core'\nimport { DotsItem, Margin } from '@nivo/core'\nimport { useTooltip } from '@nivo/tooltip'\nimport { LineSeries, LineSvgPropsWithDefaults, Point } from './types'\n\nconst NonMemoizedPoints = <Series extends LineSeries>({\n    points,\n    symbol,\n    size,\n    borderWidth,\n    enableLabel,\n    label,\n    labelYOffset,\n    isFocusable,\n    setCurrentPoint,\n    tooltip,\n    margin,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n    ariaHidden,\n    ariaDisabled,\n}: {\n    points: readonly Point<Series>[]\n    symbol: LineSvgPropsWithDefaults<Series>['pointSymbol']\n    size: number\n    borderWidth: LineSvgPropsWithDefaults<Series>['pointBorderWidth']\n    enableLabel: LineSvgPropsWithDefaults<Series>['enablePointLabel']\n    label: LineSvgPropsWithDefaults<Series>['pointLabel']\n    labelYOffset: LineSvgPropsWithDefaults<Series>['pointLabelYOffset']\n    isFocusable: LineSvgPropsWithDefaults<Series>['isFocusable']\n    setCurrentPoint: (point: Point<Series> | null) => void\n    tooltip: LineSvgPropsWithDefaults<Series>['tooltip']\n    margin: Margin\n    ariaLabel: LineSvgPropsWithDefaults<Series>['pointAriaLabel']\n    ariaLabelledBy: LineSvgPropsWithDefaults<Series>['pointAriaLabelledBy']\n    ariaDescribedBy: LineSvgPropsWithDefaults<Series>['pointAriaDescribedBy']\n    ariaHidden: LineSvgPropsWithDefaults<Series>['pointAriaHidden']\n    ariaDisabled: LineSvgPropsWithDefaults<Series>['pointAriaDisabled']\n}) => {\n    const getLabel = getLabelGenerator(label)\n\n    const { showTooltipAt, hideTooltip } = useTooltip()\n\n    // We sort the points so that the lower series are drawn on top of the higher ones.\n    const mappedPoints = points\n        .slice(0)\n        .sort((a, b) => a.indexInSeries - b.indexInSeries)\n        .sort((a, b) => b.seriesIndex - a.seriesIndex)\n        .map(point => {\n            return {\n                id: point.id,\n                x: point.x,\n                y: point.y,\n                datum: point.data,\n                fill: point.color,\n                stroke: point.borderColor,\n                label: enableLabel ? getLabel(point) : null,\n                ariaLabel: ariaLabel ? ariaLabel(point) : undefined,\n                ariaLabelledBy: ariaLabelledBy ? ariaLabelledBy(point) : undefined,\n                ariaDescribedBy: ariaDescribedBy ? ariaDescribedBy(point) : undefined,\n                ariaHidden: ariaHidden ? ariaHidden(point) : undefined,\n                ariaDisabled: ariaDisabled ? ariaDisabled(point) : undefined,\n                onFocus: isFocusable\n                    ? () => {\n                          setCurrentPoint(point)\n                          showTooltipAt(\n                              createElement(tooltip, { point }),\n                              [margin.left + point.x, margin.top + point.y],\n                              'top'\n                          )\n                      }\n                    : undefined,\n                onBlur: isFocusable\n                    ? () => {\n                          setCurrentPoint(null)\n                          hideTooltip()\n                      }\n                    : undefined,\n            }\n        })\n\n    return (\n        <g>\n            {mappedPoints.map(point => (\n                <DotsItem\n                    key={point.id}\n                    x={point.x}\n                    y={point.y}\n                    datum={point.datum}\n                    symbol={symbol as any}\n                    size={size}\n                    color={point.fill}\n                    borderWidth={borderWidth}\n                    borderColor={point.stroke}\n                    label={point.label}\n                    labelYOffset={labelYOffset}\n                    ariaLabel={point.ariaLabel}\n                    ariaLabelledBy={point.ariaLabelledBy}\n                    ariaDescribedBy={point.ariaDescribedBy}\n                    ariaHidden={point.ariaHidden}\n                    ariaDisabled={point.ariaDisabled}\n                    isFocusable={isFocusable}\n                    onFocus={point.onFocus}\n                    onBlur={point.onBlur}\n                    testId={`line.point.${point.id}`}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport const Points = memo(NonMemoizedPoints) as typeof NonMemoizedPoints\n","import { createElement, memo, useCallback, MouseEvent, TouchEvent } from 'react'\nimport { Margin } from '@nivo/core'\nimport { useTooltip } from '@nivo/tooltip'\nimport { Mesh as BaseMesh } from '@nivo/voronoi'\nimport { LineSeries, Point, LineSvgProps, LineSvgPropsWithDefaults } from './types'\n\nconst NonMemoizedMesh = <Series extends LineSeries>({\n    points,\n    width,\n    height,\n    margin,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    tooltip,\n    debug,\n    enableTouchCrosshair,\n}: {\n    points: Point<Series>[]\n    width: number\n    height: number\n    margin: Margin\n    setCurrent: (point: Point<Series> | null) => void\n    onMouseEnter?: LineSvgProps<Series>['onMouseEnter']\n    onMouseMove?: LineSvgProps<Series>['onMouseMove']\n    onMouseLeave?: LineSvgProps<Series>['onMouseLeave']\n    onMouseDown?: LineSvgProps<Series>['onMouseDown']\n    onMouseUp?: LineSvgProps<Series>['onMouseUp']\n    onClick?: LineSvgProps<Series>['onClick']\n    onDoubleClick?: LineSvgProps<Series>['onDoubleClick']\n    onTouchStart?: LineSvgProps<Series>['onTouchStart']\n    onTouchMove?: LineSvgProps<Series>['onTouchMove']\n    onTouchEnd?: LineSvgProps<Series>['onTouchEnd']\n    tooltip: LineSvgPropsWithDefaults<Series>['tooltip']\n    debug: boolean\n    enableTouchCrosshair: LineSvgPropsWithDefaults<Series>['enableTouchCrosshair']\n}) => {\n    const { showTooltipAt, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseEnter?.(point, event)\n        },\n        [showTooltipAt, tooltip, onMouseEnter, margin]\n    )\n\n    const handleMouseMove = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseMove?.(point, event)\n        },\n        [showTooltipAt, tooltip, margin.left, margin.top, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            hideTooltip()\n            onMouseLeave?.(point, event)\n        },\n        [hideTooltip, onMouseLeave]\n    )\n\n    const handleMouseDown = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            onMouseDown?.(point, event)\n        },\n        [onMouseDown]\n    )\n\n    const handleMouseUp = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            onMouseUp?.(point, event)\n        },\n        [onMouseUp]\n    )\n\n    const handleClick = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            onClick?.(point, event)\n        },\n        [onClick]\n    )\n\n    const handleDoubleClick = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            onDoubleClick?.(point, event)\n        },\n        [onDoubleClick]\n    )\n\n    const handleTouchStart = useCallback(\n        (point: Point<Series>, event: TouchEvent) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchStart?.(point, event)\n        },\n        [margin.left, margin.top, onTouchStart, showTooltipAt, tooltip]\n    )\n\n    const handleTouchMove = useCallback(\n        (point: Point<Series>, event: TouchEvent) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchMove?.(point, event)\n        },\n        [margin.left, margin.top, onTouchMove, showTooltipAt, tooltip]\n    )\n\n    const handleTouchEnd = useCallback(\n        (point: Point<Series>, event: TouchEvent) => {\n            hideTooltip()\n            onTouchEnd?.(point, event)\n        },\n        [onTouchEnd, hideTooltip]\n    )\n\n    return (\n        <BaseMesh<Point<Series>>\n            nodes={points}\n            width={width}\n            height={height}\n            setCurrent={setCurrent}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onMouseDown={handleMouseDown}\n            onMouseUp={handleMouseUp}\n            onClick={handleClick}\n            onDoubleClick={handleDoubleClick}\n            onTouchStart={handleTouchStart}\n            onTouchMove={handleTouchMove}\n            onTouchEnd={handleTouchEnd}\n            enableTouchCrosshair={enableTouchCrosshair}\n            debug={debug}\n        />\n    )\n}\n\nexport const Mesh = memo(NonMemoizedMesh) as typeof NonMemoizedMesh\n","import { Fragment, ReactNode, useState } from 'react'\nimport {\n    // @ts-expect-error no types\n    bindDefs,\n    useDimensions,\n    SvgWrapper,\n    CartesianMarkers,\n    Container,\n    LineCurveFactoryId,\n} from '@nivo/core'\nimport { InheritedColorConfig, OrdinalColorScaleConfig } from '@nivo/colors'\nimport { Axes, Grid } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { Crosshair, CrosshairType } from '@nivo/tooltip'\nimport { AnyScale } from '@nivo/scales'\nimport { useLine } from './hooks'\nimport { Areas } from './Areas'\nimport { Lines } from './Lines'\nimport { Slices } from './Slices'\nimport { Points } from './Points'\nimport { Mesh } from './Mesh'\nimport {\n    LineSeries,\n    InferSeriesId,\n    InferY,\n    LineLayerId,\n    LineSvgProps,\n    Point,\n    PointColorContext,\n    SliceData,\n    LineCustomSvgLayerProps,\n    PointTooltipComponent,\n    SliceTooltipComponent,\n    LineSvgPropsWithDefaults,\n} from './types'\nimport { svgDefaultProps } from './defaults'\n\nfunction InnerLine<Series extends LineSeries>(props: LineSvgProps<Series>) {\n    const {\n        data,\n        xScale: xScaleSpec = svgDefaultProps.xScale,\n        xFormat,\n        yScale: yScaleSpec = svgDefaultProps.yScale,\n        yFormat,\n        curve = svgDefaultProps.curve as LineCurveFactoryId,\n        margin: partialMargin,\n        width,\n        height,\n        colors = svgDefaultProps.colors as OrdinalColorScaleConfig<Series>,\n        lineWidth = svgDefaultProps.lineWidth as number,\n        layers = svgDefaultProps.layers as readonly LineLayerId[],\n        enableArea = svgDefaultProps.enableArea,\n        areaBaselineValue = svgDefaultProps.areaBaselineValue as InferY<Series>,\n        areaOpacity = svgDefaultProps.areaOpacity,\n        areaBlendMode = svgDefaultProps.areaBlendMode,\n        enablePoints = svgDefaultProps.enablePoints,\n        pointSymbol,\n        pointSize = svgDefaultProps.pointSize,\n        pointColor = svgDefaultProps.pointColor as InheritedColorConfig<PointColorContext<Series>>,\n        pointBorderWidth = svgDefaultProps.pointBorderWidth,\n        pointBorderColor = svgDefaultProps.pointBorderColor as InheritedColorConfig<\n            Omit<Point<Series>, 'borderColor'>\n        >,\n        enablePointLabel = svgDefaultProps.enablePointLabel,\n        pointLabel = svgDefaultProps.pointLabel as string,\n        pointLabelYOffset,\n        enableGridX = svgDefaultProps.enableGridX,\n        gridXValues,\n        enableGridY = svgDefaultProps.enableGridY,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom = svgDefaultProps.axisBottom,\n        axisLeft = svgDefaultProps.axisLeft,\n        defs = svgDefaultProps.defs,\n        fill = svgDefaultProps.fill,\n        markers,\n        legends = svgDefaultProps.legends,\n        isInteractive = svgDefaultProps.isInteractive,\n        useMesh = svgDefaultProps.useMesh,\n        debugMesh = svgDefaultProps.debugMesh,\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onMouseDown,\n        onMouseUp,\n        onClick,\n        onDoubleClick,\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd,\n        tooltip = svgDefaultProps.tooltip as PointTooltipComponent<Series>,\n        enableSlices = svgDefaultProps.enableSlices,\n        debugSlices = svgDefaultProps.debugSlices,\n        sliceTooltip = svgDefaultProps.sliceTooltip as SliceTooltipComponent<Series>,\n        enableCrosshair = svgDefaultProps.enableCrosshair,\n        crosshairType = svgDefaultProps.crosshairType as CrosshairType,\n        enableTouchCrosshair = svgDefaultProps.enableTouchCrosshair,\n        role = svgDefaultProps.role,\n        ariaLabel,\n        ariaLabelledBy,\n        ariaDescribedBy,\n        isFocusable = svgDefaultProps.isFocusable,\n        pointAriaLabel,\n        pointAriaLabelledBy,\n        pointAriaDescribedBy,\n        pointAriaHidden,\n        pointAriaDisabled,\n        initialHiddenIds = svgDefaultProps.initialHiddenIds as InferSeriesId<Series>[],\n    } = props\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        legendData,\n        toggleSeries,\n        lineGenerator,\n        areaGenerator,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    } = useLine<Series>({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n        enableSlices,\n        initialHiddenIds,\n    })\n\n    const [currentPoint, setCurrentPoint] = useState<Point<Series> | null>(null)\n    const [currentSlice, setCurrentSlice] = useState<SliceData<Series> | null>(null)\n\n    const layerById: Record<LineLayerId, ReactNode> = {\n        grid: null,\n        markers: null,\n        axes: null,\n        areas: null,\n        crosshair: null,\n        lines: null,\n        points: null,\n        slices: null,\n        mesh: null,\n        legends: null,\n    }\n\n    if (layers.includes('grid') && (enableGridX || enableGridY)) {\n        layerById.grid = (\n            <Grid\n                key=\"grid\"\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? (xScale as AnyScale) : null}\n                yScale={enableGridY ? (yScale as AnyScale) : null}\n                xValues={gridXValues}\n                yValues={gridYValues}\n            />\n        )\n    }\n\n    if (layers.includes('markers') && Array.isArray(markers) && markers.length > 0) {\n        layerById.markers = (\n            <CartesianMarkers\n                key=\"markers\"\n                markers={markers}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={xScale}\n                yScale={yScale}\n            />\n        )\n    }\n\n    if (layers.includes('axes')) {\n        layerById.axes = (\n            <Axes\n                key=\"axes\"\n                xScale={xScale as AnyScale}\n                yScale={yScale as AnyScale}\n                width={innerWidth}\n                height={innerHeight}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        )\n    }\n\n    if (layers.includes('lines')) {\n        layerById.lines = (\n            <Lines<Series>\n                key=\"lines\"\n                series={series}\n                lineGenerator={lineGenerator}\n                lineWidth={lineWidth}\n            />\n        )\n    }\n\n    if (layers.includes('legends') && legends.length > 0) {\n        layerById.legends = (\n            <Fragment key=\"legends\">\n                {legends.map((legend, i) => (\n                    <BoxLegendSvg\n                        key={i}\n                        {...legend}\n                        containerWidth={innerWidth}\n                        containerHeight={innerHeight}\n                        data={legend.data || legendData}\n                        toggleSerie={\n                            legend.toggleSerie\n                                ? (toggleSeries as (id: string | number) => void)\n                                : undefined\n                        }\n                    />\n                ))}\n            </Fragment>\n        )\n    }\n\n    const boundDefs = bindDefs(defs, series, fill)\n\n    if (enableArea) {\n        layerById.areas = (\n            <Areas<Series>\n                key=\"areas\"\n                areaGenerator={areaGenerator}\n                areaOpacity={areaOpacity}\n                areaBlendMode={areaBlendMode}\n                series={series}\n            />\n        )\n    }\n\n    if (isInteractive && enableSlices !== false) {\n        layerById.slices = (\n            <Slices<Series>\n                key=\"slices\"\n                slices={slices}\n                axis={enableSlices}\n                debug={debugSlices}\n                tooltip={sliceTooltip}\n                current={currentSlice}\n                setCurrent={setCurrentSlice}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onMouseDown={onMouseDown}\n                onMouseUp={onMouseUp}\n                onClick={onClick}\n                onDoubleClick={onDoubleClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n            />\n        )\n    }\n\n    if (enablePoints) {\n        layerById.points = (\n            <Points<Series>\n                key=\"points\"\n                points={points}\n                symbol={pointSymbol}\n                size={pointSize}\n                borderWidth={pointBorderWidth}\n                enableLabel={enablePointLabel}\n                label={pointLabel}\n                labelYOffset={pointLabelYOffset}\n                isFocusable={isFocusable}\n                setCurrentPoint={setCurrentPoint}\n                tooltip={tooltip}\n                margin={margin}\n                ariaLabel={pointAriaLabel}\n                ariaLabelledBy={pointAriaLabelledBy}\n                ariaDescribedBy={pointAriaDescribedBy}\n                ariaHidden={pointAriaHidden}\n                ariaDisabled={pointAriaDisabled}\n            />\n        )\n    }\n\n    if (isInteractive && enableCrosshair) {\n        if (currentPoint !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentPoint.x}\n                    y={currentPoint.y}\n                    type={crosshairType}\n                />\n            )\n        }\n        if (currentSlice !== null && enableSlices) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentSlice.x}\n                    y={currentSlice.y}\n                    type={enableSlices}\n                />\n            )\n        }\n    }\n\n    if (isInteractive && useMesh && enableSlices === false) {\n        layerById.mesh = (\n            <Mesh<Series>\n                key=\"mesh\"\n                points={points}\n                width={innerWidth}\n                height={innerHeight}\n                margin={margin}\n                setCurrent={setCurrentPoint}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onMouseDown={onMouseDown}\n                onMouseUp={onMouseUp}\n                onClick={onClick}\n                onDoubleClick={onDoubleClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n                tooltip={tooltip}\n                enableTouchCrosshair={enableTouchCrosshair}\n                debug={debugMesh}\n            />\n        )\n    }\n\n    const customLayerProps: LineCustomSvgLayerProps<Series> = {\n        ...(props as LineSvgPropsWithDefaults<Series>),\n        innerWidth,\n        innerHeight,\n        series,\n        slices,\n        points,\n        xScale,\n        yScale,\n        lineGenerator,\n        areaGenerator,\n        currentPoint,\n        setCurrentPoint,\n        currentSlice,\n        setCurrentSlice,\n    }\n\n    return (\n        <SvgWrapper\n            defs={boundDefs}\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            ariaDescribedBy={ariaDescribedBy}\n            isFocusable={isFocusable}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{layer(customLayerProps)}</Fragment>\n                }\n\n                return layerById[layer]\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport function Line<Series extends LineSeries>({\n    isInteractive = svgDefaultProps.isInteractive,\n    animate = svgDefaultProps.animate,\n    motionConfig = svgDefaultProps.motionConfig,\n    theme,\n    renderWrapper,\n    ...otherProps\n}: LineSvgProps<Series>) {\n    return (\n        <Container\n            {...{\n                animate,\n                isInteractive,\n                motionConfig,\n                renderWrapper,\n                theme,\n            }}\n        >\n            <InnerLine<Series> isInteractive={isInteractive} {...otherProps} />\n        </Container>\n    )\n}\n","import {\n    createElement,\n    useRef,\n    useEffect,\n    useState,\n    useCallback,\n    forwardRef,\n    ForwardedRef,\n    MouseEvent,\n    useMemo,\n    ReactElement,\n    Ref,\n} from 'react'\nimport { useDimensions, getRelativeCursor, isCursorInRect, Container, mergeRefs } from '@nivo/core'\nimport { useTheme } from '@nivo/theming'\nimport { renderAxesToCanvas, renderGridLinesToCanvas } from '@nivo/axes'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useTooltip } from '@nivo/tooltip'\nimport { useVoronoiMesh, renderVoronoiToCanvas, renderVoronoiCellToCanvas } from '@nivo/voronoi'\nimport { OrdinalColorScaleConfig, InheritedColorConfig } from '@nivo/colors'\nimport { useLine } from './hooks'\nimport {\n    InferY,\n    LineCanvasProps,\n    LineLayerId,\n    LineSeries,\n    PointTooltipComponent,\n    Point,\n    LineCustomCanvasLayerProps,\n    PointColorContext,\n} from './types'\nimport { canvasDefaultProps } from './defaults'\nimport { AnyScale } from '@nivo/scales'\n\nconst InnerLineCanvas = <Series extends LineSeries>({\n    width,\n    height,\n    margin: partialMargin,\n    pixelRatio = canvasDefaultProps.pixelRatio,\n\n    data,\n    xScale: xScaleSpec = canvasDefaultProps.xScale,\n    xFormat,\n    yScale: yScaleSpec = canvasDefaultProps.yScale,\n    yFormat,\n    curve = canvasDefaultProps.curve,\n\n    layers = canvasDefaultProps.layers as LineLayerId[],\n\n    colors = canvasDefaultProps.colors as OrdinalColorScaleConfig<Series>,\n    lineWidth = canvasDefaultProps.lineWidth,\n\n    enableArea = canvasDefaultProps.enableArea,\n    areaBaselineValue = canvasDefaultProps.areaBaselineValue as InferY<Series>,\n    areaOpacity = canvasDefaultProps.areaOpacity,\n\n    enablePoints = canvasDefaultProps.enablePoints,\n    pointSize = canvasDefaultProps.pointSize,\n    pointColor = canvasDefaultProps.pointColor as InheritedColorConfig<PointColorContext<Series>>,\n    pointBorderWidth = canvasDefaultProps.pointBorderWidth,\n    pointBorderColor = canvasDefaultProps.pointBorderColor as InheritedColorConfig<\n        Omit<Point<Series>, 'borderColor'>\n    >,\n\n    enableGridX = canvasDefaultProps.enableGridX,\n    gridXValues,\n    enableGridY = canvasDefaultProps.enableGridY,\n    gridYValues,\n    axisTop,\n    axisRight,\n    axisBottom = canvasDefaultProps.axisBottom,\n    axisLeft = canvasDefaultProps.axisLeft,\n\n    legends = canvasDefaultProps.legends,\n\n    isInteractive = canvasDefaultProps.isInteractive,\n    debugMesh = canvasDefaultProps.debugMesh,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    tooltip = canvasDefaultProps.tooltip as PointTooltipComponent<Series>,\n    forwardedRef,\n}: Omit<LineCanvasProps<Series>, 'renderWrapper' | 'theme'> & {\n    forwardedRef: Ref<HTMLCanvasElement>\n}) => {\n    const canvasEl = useRef<HTMLCanvasElement | null>(null)\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n    const theme = useTheme()\n    const [currentPoint, setCurrentPoint] = useState<Point<Series> | null>(null)\n\n    const { lineGenerator, areaGenerator, series, xScale, yScale, points } = useLine<Series>({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n    })\n\n    const customLayerProps: LineCustomCanvasLayerProps<Series> = useMemo(\n        () => ({\n            innerWidth,\n            innerHeight,\n            series,\n            points,\n            xScale,\n            yScale,\n            lineWidth,\n            lineGenerator,\n            areaGenerator,\n            currentPoint,\n            setCurrentPoint,\n        }),\n        [\n            innerWidth,\n            innerHeight,\n            series,\n            points,\n            xScale,\n            yScale,\n            lineWidth,\n            lineGenerator,\n            areaGenerator,\n            currentPoint,\n            setCurrentPoint,\n        ]\n    )\n\n    const { delaunay, voronoi } = useVoronoiMesh({\n        points,\n        width: innerWidth,\n        height: innerHeight,\n        debug: debugMesh,\n    })\n\n    useEffect(() => {\n        if (canvasEl.current === null) return\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        const ctx = canvasEl.current.getContext('2d')!\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        layers.forEach(layer => {\n            if (typeof layer === 'function') {\n                layer(ctx, customLayerProps)\n            }\n\n            const gridLineWidth = theme.grid.line.strokeWidth ?? 0\n            if (layer === 'grid' && typeof gridLineWidth !== 'string' && gridLineWidth > 0) {\n                ctx.lineWidth = gridLineWidth\n                ctx.strokeStyle = theme.grid.line.stroke as string\n\n                if (enableGridX) {\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: xScale as AnyScale,\n                        axis: 'x',\n                        values: gridXValues,\n                    })\n                }\n\n                if (enableGridY) {\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: yScale as AnyScale,\n                        axis: 'y',\n                        values: gridYValues,\n                    })\n                }\n            }\n\n            if (layer === 'axes') {\n                renderAxesToCanvas(ctx, {\n                    xScale: xScale as AnyScale,\n                    yScale: yScale as AnyScale,\n                    width: innerWidth,\n                    height: innerHeight,\n                    top: axisTop,\n                    right: axisRight,\n                    bottom: axisBottom,\n                    left: axisLeft,\n                    theme,\n                })\n            }\n\n            if (layer === 'areas' && enableArea === true) {\n                ctx.save()\n                ctx.globalAlpha = areaOpacity\n\n                areaGenerator.context(ctx)\n                for (let i = series.length - 1; i >= 0; i--) {\n                    ctx.fillStyle = series[i].color\n                    ctx.beginPath()\n                    areaGenerator(series[i].data.map(d => d.position))\n                    ctx.fill()\n                }\n\n                ctx.restore()\n            }\n\n            if (layer === 'lines') {\n                lineGenerator.context(ctx)\n                series.forEach(seriesItem => {\n                    ctx.strokeStyle = seriesItem.color\n                    ctx.lineWidth = lineWidth\n                    ctx.beginPath()\n                    lineGenerator(seriesItem.data.map(d => d.position))\n                    ctx.stroke()\n                })\n            }\n\n            if (layer === 'points' && enablePoints === true && pointSize > 0) {\n                points.forEach(point => {\n                    ctx.fillStyle = point.color\n                    ctx.beginPath()\n                    ctx.arc(point.x, point.y, pointSize / 2, 0, 2 * Math.PI)\n                    ctx.fill()\n\n                    if (pointBorderWidth > 0) {\n                        ctx.strokeStyle = point.borderColor\n                        ctx.lineWidth = pointBorderWidth\n                        ctx.stroke()\n                    }\n                })\n            }\n\n            if (layer === 'mesh' && debugMesh === true && voronoi !== undefined) {\n                renderVoronoiToCanvas(ctx, voronoi)\n                if (currentPoint) {\n                    renderVoronoiCellToCanvas(ctx, voronoi, currentPoint.absIndex)\n                }\n            }\n\n            if (layer === 'legends') {\n                const legendData = series\n                    .map(serie => ({\n                        id: serie.id,\n                        label: serie.id,\n                        color: serie.color,\n                    }))\n                    .reverse()\n\n                legends.forEach(legend => {\n                    renderLegendToCanvas(ctx, {\n                        ...legend,\n                        data: legend.data || legendData,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        theme,\n                    })\n                })\n            }\n        })\n    }, [\n        canvasEl,\n        innerWidth,\n        outerWidth,\n        innerHeight,\n        outerHeight,\n        margin.left,\n        margin.top,\n        pixelRatio,\n        layers,\n        theme,\n        lineGenerator,\n        series,\n        xScale,\n        yScale,\n        enableGridX,\n        gridXValues,\n        enableGridY,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom,\n        axisLeft,\n        legends,\n        points,\n        enablePoints,\n        pointSize,\n        pointBorderWidth,\n        currentPoint,\n        customLayerProps,\n        debugMesh,\n        enableArea,\n        areaGenerator,\n        areaOpacity,\n        lineWidth,\n        voronoi,\n    ])\n\n    const getPointFromMouseEvent = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (!canvasEl.current) return null\n\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n            if (!isCursorInRect(margin.left, margin.top, innerWidth, innerHeight, x, y)) return null\n\n            const pointIndex = delaunay.find(x - margin.left, y - margin.top)\n            return points[pointIndex]\n        },\n        [canvasEl, margin, innerWidth, innerHeight, delaunay, points]\n    )\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseHover = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            const point = getPointFromMouseEvent(event)\n            setCurrentPoint(point)\n\n            if (point) {\n                showTooltipFromEvent(createElement(tooltip, { point }), event)\n            } else {\n                hideTooltip()\n            }\n        },\n        [getPointFromMouseEvent, setCurrentPoint, showTooltipFromEvent, hideTooltip, tooltip]\n    )\n\n    const handleMouseLeave = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            hideTooltip()\n            setCurrentPoint(null)\n            if (currentPoint) onMouseLeave?.(currentPoint, event)\n        },\n        [hideTooltip, setCurrentPoint, onMouseLeave, currentPoint]\n    )\n\n    const handleMouseDown = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (onMouseDown) {\n                const point = getPointFromMouseEvent(event)\n                if (point) onMouseDown(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onMouseDown]\n    )\n\n    const handleMouseUp = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (onMouseUp) {\n                const point = getPointFromMouseEvent(event)\n                if (point) onMouseUp(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onMouseUp]\n    )\n\n    const handleClick = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (onClick) {\n                const point = getPointFromMouseEvent(event)\n                if (point) onClick(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onClick]\n    )\n\n    const handleDoubleClick = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (onDoubleClick) {\n                const point = getPointFromMouseEvent(event)\n                if (point) onDoubleClick(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onDoubleClick]\n    )\n\n    return (\n        <canvas\n            ref={mergeRefs<HTMLCanvasElement>(canvasEl, forwardedRef)}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n                cursor: isInteractive ? 'auto' : 'normal',\n            }}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n            onMouseDown={isInteractive ? handleMouseDown : undefined}\n            onMouseUp={isInteractive ? handleMouseUp : undefined}\n            onClick={isInteractive ? handleClick : undefined}\n            onDoubleClick={isInteractive ? handleDoubleClick : undefined}\n        />\n    )\n}\n\nexport const LineCanvas = forwardRef(\n    <Series extends LineSeries>(\n        { isInteractive, renderWrapper, theme, ...props }: LineCanvasProps<Series>,\n        ref: Ref<HTMLCanvasElement>\n    ) => (\n        <Container {...{ isInteractive, renderWrapper, theme }} animate={false}>\n            <InnerLineCanvas<Series> {...props} forwardedRef={ref} />\n        </Container>\n    )\n) as <Series extends LineSeries>(\n    props: LineCanvasProps<Series> & {\n        ref?: ForwardedRef<HTMLCanvasElement>\n    }\n) => ReactElement\n","import { forwardRef, Ref, ReactElement } from 'react'\nimport { ResponsiveWrapper } from '@nivo/core'\nimport { LineCanvasProps, LineSeries } from './types'\nimport { LineCanvas } from './LineCanvas'\n\nexport type ResponsiveLineCanvasProps<Series extends LineSeries> = Omit<\n    LineCanvasProps<Series>,\n    'width' | 'height'\n>\n\nfunction InnerResponsiveLineCanvas<Series extends LineSeries>(\n    props: ResponsiveLineCanvasProps<Series>,\n    ref: Ref<HTMLCanvasElement>\n) {\n    return (\n        <ResponsiveWrapper>\n            {({ width, height }: { width: number; height: number }) => (\n                <LineCanvas<Series> width={width} height={height} {...props} ref={ref} />\n            )}\n        </ResponsiveWrapper>\n    )\n}\n\nexport const ResponsiveLineCanvas = forwardRef<HTMLCanvasElement, ResponsiveLineCanvasProps<any>>(\n    InnerResponsiveLineCanvas\n) as <Series extends LineSeries>(\n    props: ResponsiveLineCanvasProps<Series> & {\n        ref?: Ref<HTMLCanvasElement>\n    }\n) => ReactElement\n","import { ResponsiveWrapper } from '@nivo/core'\nimport { Line } from './Line'\nimport { LineSvgProps, LineSeries } from './types'\n\nexport const ResponsiveLine = <Series extends LineSeries>(\n    props: Omit<LineSvgProps<Series>, 'width' | 'height'>\n) => {\n    return (\n        <ResponsiveWrapper>\n            {({ width, height }: { width: number; height: number }) => (\n                <Line<Series> width={width} height={height} {...props} />\n            )}\n        </ResponsiveWrapper>\n    )\n}\n","import { FunctionComponent, MouseEvent, TouchEvent, AriaAttributes } from 'react'\nimport { Line, Area } from 'd3-shape'\nimport {\n    Dimensions,\n    Box,\n    MotionProps,\n    CssMixBlendMode,\n    ValueFormat,\n    SvgDefsAndFill,\n    CartesianMarkerProps,\n    PropertyAccessor,\n    LineCurveFactoryId,\n    DotsItemSymbolComponent,\n} from '@nivo/core'\nimport { PartialTheme } from '@nivo/theming'\nimport { AxisProps, CanvasAxisProps } from '@nivo/axes'\nimport { InheritedColorConfig, OrdinalColorScaleConfig } from '@nivo/colors'\nimport { ScaleSpec, TicksSpec } from '@nivo/scales'\nimport { LegendProps } from '@nivo/legends'\nimport { CrosshairType } from '@nivo/tooltip'\n\nexport type AllowedSeriesId = string | number\n// `null` is allowed in the data to indicate a missing value.\nexport type AllowedValue = string | number | Date | null\nexport type LineSeries = {\n    id: AllowedSeriesId\n    data: readonly { x: AllowedValue; y: AllowedValue }[]\n}\n\nexport type InferSeriesId<T> = T extends { id: infer Id } ? Id : never\n\nexport type InferX<T> = T extends { data: ReadonlyArray<infer D> }\n    ? D extends { x: infer X }\n        ? X\n        : never\n    : never\nexport type InferY<T> = T extends { data: ReadonlyArray<infer D> }\n    ? D extends { y: infer Y }\n        ? Y\n        : never\n    : never\n\nexport type DefaultSeries = {\n    id: string\n    data: readonly {\n        x: string | null\n        y: number | null\n    }[]\n}\n\nexport interface ComputedDatum<Series extends LineSeries> {\n    data: Series['data'][number]\n    position: {\n        x: number\n        y: number\n    }\n}\n\nexport type ComputedSeries<Series extends LineSeries> = Omit<Series, 'data' | 'id'> & {\n    id: InferSeriesId<Series>\n    data: readonly ComputedDatum<Series>[]\n    color: string\n}\n\nexport interface Point<Series extends LineSeries> {\n    id: string\n    indexInSeries: number\n    absIndex: number\n    seriesIndex: number\n    seriesId: InferSeriesId<Series>\n    seriesColor: string\n    x: number\n    y: number\n    color: string\n    borderColor: string\n    data: Series['data'][number] & {\n        xFormatted: string\n        yFormatted: string\n    }\n}\n\nexport type PointColorContext<Series extends LineSeries> = {\n    series: ComputedSeries<Series>\n    point: Omit<Point<Series>, 'color' | 'borderColor'>\n}\n\nexport interface SliceData<Series extends LineSeries> {\n    id: string\n    x0: number\n    x: number\n    y0: number\n    y: number\n    width: number\n    height: number\n    points: readonly Point<Series>[]\n}\n\nexport type PointOrSliceData<Series extends LineSeries> = Point<Series> | SliceData<Series>\nexport function isPoint<Series extends LineSeries>(\n    data: PointOrSliceData<Series>\n): data is Point<Series> {\n    return (data as Point<Series>).seriesId !== undefined\n}\nexport function isSliceData<Series extends LineSeries>(\n    data: PointOrSliceData<Series>\n): data is SliceData<Series> {\n    return (data as SliceData<Series>).points !== undefined\n}\n\nexport interface DataProps<Series extends LineSeries> {\n    data: readonly Series[]\n}\n\nexport type LineGenerator = Line<{ x: number; y: number }>\nexport type AreaGenerator = Area<{ x: number; y: number }>\n\nexport interface PointTooltipProps<Series extends LineSeries> {\n    point: Point<Series>\n}\nexport type PointTooltipComponent<Series extends LineSeries> = FunctionComponent<\n    PointTooltipProps<Series>\n>\n\nexport interface SliceTooltipProps<Series extends LineSeries> {\n    axis: 'x' | 'y'\n    slice: SliceData<Series>\n}\nexport type SliceTooltipComponent<Series extends LineSeries> = FunctionComponent<\n    SliceTooltipProps<Series>\n>\n\nexport type PointOrSliceMouseHandler<Series extends LineSeries> = (\n    datum: Readonly<Point<Series>> | Readonly<SliceData<Series>>,\n    event: MouseEvent\n) => void\nexport type PointOrSliceTouchHandler<Series extends LineSeries> = (\n    datum: Readonly<Point<Series>> | Readonly<SliceData<Series>>,\n    event: TouchEvent\n) => void\n\nexport type LineLayerId =\n    | 'grid'\n    | 'markers'\n    | 'axes'\n    | 'areas'\n    | 'crosshair'\n    | 'lines'\n    | 'slices'\n    | 'points'\n    | 'mesh'\n    | 'legends'\n\nexport interface CommonCustomLayerProps<Series extends LineSeries> {\n    innerWidth: number\n    innerHeight: number\n    series: readonly ComputedSeries<Series>[]\n    points: readonly Point<Series>[]\n    xScale: (x: InferX<Series>) => number\n    yScale: (y: InferY<Series>) => number\n    lineGenerator: LineGenerator\n    areaGenerator: AreaGenerator\n    currentPoint: Point<Series> | null\n    setCurrentPoint: (point: Point<Series> | null) => void\n}\n\nexport type LineCustomSvgLayerProps<Series extends LineSeries> = Omit<\n    LineSvgPropsWithDefaults<Series>,\n    'xScale' | 'yScale'\n> &\n    CommonCustomLayerProps<Series> & {\n        slices: readonly SliceData<Series>[]\n        currentSlice: SliceData<Series> | null\n        setCurrentSlice: (slice: SliceData<Series> | null) => void\n    }\nexport type LineCustomSvgLayer<Series extends LineSeries> = FunctionComponent<\n    LineCustomSvgLayerProps<Series>\n>\nexport type LineSvgLayer<Series extends LineSeries> = LineLayerId | LineCustomSvgLayer<Series>\n\nexport type LineCustomCanvasLayerProps<Series extends LineSeries> = CommonCustomLayerProps<Series>\nexport type LineCustomCanvasLayer<Series extends LineSeries> = (\n    context: CanvasRenderingContext2D,\n    props: LineCustomCanvasLayerProps<Series>\n) => void\nexport type LineCanvasLayer<Series extends LineSeries> = LineLayerId | LineCustomCanvasLayer<Series>\n\nexport type CommonLineProps<Series extends LineSeries> = {\n    xScale: ScaleSpec\n    xFormat?: ValueFormat<InferX<Series>>\n    yScale: ScaleSpec\n    yFormat?: ValueFormat<InferY<Series>>\n    margin: Box\n    curve: LineCurveFactoryId\n    theme: PartialTheme\n    colors: OrdinalColorScaleConfig<Series>\n    lineWidth: number\n    enablePoints: boolean\n    pointSymbol?: DotsItemSymbolComponent<Point<Series>>\n    pointSize: number\n    pointColor: InheritedColorConfig<PointColorContext<Series>>\n    pointBorderWidth: number\n    pointBorderColor: InheritedColorConfig<Omit<Point<Series>, 'borderColor'>>\n    enableArea: boolean\n    areaBaselineValue: InferY<Series>\n    areaOpacity: number\n    enableGridX: boolean\n    gridXValues?: TicksSpec<InferX<Series>>\n    enableGridY: boolean\n    gridYValues?: TicksSpec<InferY<Series>>\n    legends: readonly LegendProps[]\n    isInteractive: boolean\n    debugMesh: boolean\n    onMouseEnter?: PointOrSliceMouseHandler<Series>\n    onMouseMove?: PointOrSliceMouseHandler<Series>\n    onMouseLeave?: PointOrSliceMouseHandler<Series>\n    onMouseDown?: PointOrSliceMouseHandler<Series>\n    onMouseUp?: PointOrSliceMouseHandler<Series>\n    onClick?: PointOrSliceMouseHandler<Series>\n    onDoubleClick?: PointOrSliceMouseHandler<Series>\n    onTouchStart?: PointOrSliceTouchHandler<Series>\n    onTouchMove?: PointOrSliceTouchHandler<Series>\n    onTouchEnd?: PointOrSliceTouchHandler<Series>\n    tooltip: PointTooltipComponent<Series>\n    sliceTooltip: SliceTooltipComponent<Series>\n    renderWrapper: boolean\n}\n\nexport interface LineSvgExtraProps<Series extends LineSeries> {\n    layers: readonly LineSvgLayer<Series>[]\n    enablePointLabel: boolean\n    pointLabel: PropertyAccessor<Point<Series>, string>\n    pointLabelYOffset?: number\n    areaBlendMode: CssMixBlendMode\n    axisTop?: AxisProps | null\n    axisRight?: AxisProps | null\n    axisBottom?: AxisProps | null\n    axisLeft?: AxisProps | null\n    useMesh: boolean\n    enableSlices: 'x' | 'y' | false\n    debugSlices: boolean\n    enableCrosshair: boolean\n    crosshairType: CrosshairType\n    enableTouchCrosshair: boolean\n    markers?: readonly CartesianMarkerProps[]\n    initialHiddenIds: readonly InferSeriesId<Series>[]\n    animate: boolean\n    motionConfig: MotionProps['motionConfig']\n    role: string\n    ariaLabel?: AriaAttributes['aria-label']\n    ariaLabelledBy?: AriaAttributes['aria-labelledby']\n    ariaDescribedBy?: AriaAttributes['aria-describedby']\n    isFocusable: boolean\n    pointAriaLabel?: (point: Point<Series>) => AriaAttributes['aria-label']\n    pointAriaLabelledBy?: (point: Point<Series>) => AriaAttributes['aria-labelledby']\n    pointAriaDescribedBy?: (point: Point<Series>) => AriaAttributes['aria-describedby']\n    pointAriaHidden?: (point: Point<Series>) => AriaAttributes['aria-hidden']\n    pointAriaDisabled?: (point: Point<Series>) => AriaAttributes['aria-disabled']\n}\nexport type LineSvgProps<Series extends LineSeries> = DataProps<Series> &\n    Dimensions &\n    Partial<CommonLineProps<Series>> &\n    Partial<LineSvgExtraProps<Series>> &\n    SvgDefsAndFill<any>\nexport type LineSvgPropsWithDefaults<Series extends LineSeries> = DataProps<Series> &\n    Dimensions &\n    CommonLineProps<Series> &\n    LineSvgExtraProps<Series> &\n    SvgDefsAndFill<any>\n\nexport interface LineCanvasExtraProps<Series extends LineSeries> {\n    layers: readonly LineCanvasLayer<Series>[]\n    pixelRatio: number\n    axisTop?: CanvasAxisProps | null\n    axisRight?: CanvasAxisProps | null\n    axisBottom?: CanvasAxisProps | null\n    axisLeft?: CanvasAxisProps | null\n}\nexport type LineCanvasProps<Series extends LineSeries> = DataProps<Series> &\n    Dimensions &\n    Partial<CommonLineProps<Series>> &\n    Partial<LineCanvasExtraProps<Series>>\nexport type LineCanvasPropsWithDefaults<Series extends LineSeries> = DataProps<Series> &\n    Dimensions &\n    CommonLineProps<Series> &\n    LineCanvasExtraProps<Series>\n"],"names":["commonDefaultProps","xScale","type","yScale","min","max","curve","colors","scheme","lineWidth","layers","enablePoints","pointSize","pointColor","from","pointBorderWidth","pointBorderColor","theme","enableArea","areaBaselineValue","areaOpacity","enableGridX","enableGridY","legends","isInteractive","tooltip","memo","_ref","point","_jsx","BasicTooltip","id","_jsxs","jsxs","children","jsx","data","xFormatted","yFormatted","enableChip","color","seriesColor","sliceTooltip","slice","axis","useTheme","otherAxis","TableTooltip","rows","points","map","Chip","style","chip","seriesId","tableCellValue","debugMesh","renderWrapper","svgDefaultProps","_extends","defs","fill","enablePointLabel","pointLabel","areaBlendMode","axisBottom","axisLeft","useMesh","enableSlices","debugSlices","enableCrosshair","crosshairType","enableTouchCrosshair","initialHiddenIds","animate","motionConfig","role","isFocusable","canvasDefaultProps","pixelRatio","window","_window$devicePixelRa","devicePixelRatio","useLineGenerator","useMemo","line","defined","d","x","y","curveFromProp","useAreaGenerator","area","y1","y0","useSlices","_ref3","componentId","width","height","Map","forEach","has","get","push","set","Array","entries","sort","a","b","_ref4","i","slices","x0","sliceWidth","slicePoints","prevSlice","nextSlice","reverse","_ref5","sliceHeight","LINE_UNIQUE_ID_PREFIX","useLine","_ref6","_ref6$xScale","xScaleSpec","xFormat","_ref6$yScale","yScaleSpec","yFormat","_ref6$colors","_ref6$curve","_ref6$areaBaselineVal","_ref6$pointColor","_ref6$pointBorderColo","_ref6$enableSlices","_ref6$initialHiddenId","useState","uniqueId","formatX","useValueFormatter","formatY","getColor","useOrdinalColorScale","getPointColor","useInheritedColor","getPointBorderColor","_useState2","hiddenIds","setHiddenIds","_useMemo","computeXYScalesForSeries","filter","item","indexOf","rawSeries","series","_useMemo2","dataWithColor","seriesItem","label","datum","find","Boolean","legendData","hidden","toggleSeries","useCallback","state","concat","_ref2","reduce","acc","seriesIndex","position","indexInSeries","absIndex","length","borderColor","usePoints","lineGenerator","areaGenerator","AreaPath","path","_useMotionConfig","useMotionConfig","springConfig","config","animatedPath","useAnimatedPath","animatedProps","useSpring","immediate","animated","fillOpacity","strokeWidth","mixBlendMode","Areas","reversedSeries","LinesItem","thickness","stroke","Lines","_Fragment","SlicesItem","debug","isCurrent","setCurrent","onMouseEnter","onMouseMove","onMouseLeave","onMouseDown","onMouseUp","onClick","onDoubleClick","onTouchStart","onTouchMove","onTouchEnd","_useTooltip","useTooltip","showTooltipFromEvent","hideTooltip","handleMouseEnter","event","createElement","handleMouseMove","handleMouseLeave","handleMouseDown","handleMouseUp","handleClick","handleDoubleClick","handeOnTouchStart","handeOnTouchMove","touchPoint","touches","touchingElement","document","elementFromPoint","clientX","clientY","touchingSliceId","getAttribute","handleOnTouchEnd","strokeOpacity","Slices","current","Points","symbol","size","borderWidth","enableLabel","labelYOffset","setCurrentPoint","margin","ariaLabel","ariaLabelledBy","ariaDescribedBy","ariaHidden","ariaDisabled","getLabel","getLabelGenerator","showTooltipAt","mappedPoints","undefined","onFocus","left","top","onBlur","DotsItem","testId","Mesh","handleTouchStart","handleTouchMove","handleTouchEnd","BaseMesh","nodes","InnerLine","props","_props$xScale","_props$yScale","_props$curve","partialMargin","_props$colors","_props$lineWidth","_props$layers","_props$enableArea","_props$areaBaselineVa","_props$areaOpacity","_props$areaBlendMode","_props$enablePoints","pointSymbol","_props$pointSize","_props$pointColor","_props$pointBorderWid","_props$pointBorderCol","_props$enablePointLab","_props$pointLabel","pointLabelYOffset","_props$enableGridX","gridXValues","_props$enableGridY","gridYValues","axisTop","axisRight","_props$axisBottom","_props$axisLeft","_props$defs","_props$fill","markers","_props$legends","_props$isInteractive","_props$useMesh","_props$debugMesh","_props$tooltip","_props$enableSlices","_props$debugSlices","_props$sliceTooltip","_props$enableCrosshai","_props$crosshairType","_props$enableTouchCro","_props$role","_props$isFocusable","pointAriaLabel","pointAriaLabelledBy","pointAriaDescribedBy","pointAriaHidden","pointAriaDisabled","_props$initialHiddenI","_useDimensions","useDimensions","innerWidth","innerHeight","outerWidth","outerHeight","_useLine","_useState","currentPoint","currentSlice","setCurrentSlice","layerById","grid","axes","areas","crosshair","lines","mesh","includes","Grid","xValues","yValues","isArray","CartesianMarkers","Axes","right","bottom","Fragment","legend","BoxLegendSvg","containerWidth","containerHeight","toggleSerie","boundDefs","bindDefs","Crosshair","customLayerProps","SvgWrapper","layer","Line","_ref$isInteractive","_ref$animate","_ref$motionConfig","otherProps","_objectWithoutPropertiesLoose","_excluded","Container","InnerLineCanvas","_ref$pixelRatio","_ref$xScale","_ref$yScale","_ref$curve","_ref$layers","_ref$colors","_ref$lineWidth","_ref$enableArea","_ref$areaBaselineValu","_ref$areaOpacity","_ref$enablePoints","_ref$pointSize","_ref$pointColor","_ref$pointBorderWidth","_ref$pointBorderColor","_ref$enableGridX","_ref$enableGridY","_ref$axisBottom","_ref$axisLeft","_ref$legends","_ref$debugMesh","_ref$tooltip","forwardedRef","canvasEl","useRef","_useVoronoiMesh","useVoronoiMesh","delaunay","voronoi","useEffect","ctx","getContext","scale","fillStyle","background","fillRect","translate","_theme$grid$line$stro","gridLineWidth","strokeStyle","renderGridLinesToCanvas","values","renderAxesToCanvas","save","globalAlpha","context","beginPath","restore","arc","Math","PI","renderVoronoiToCanvas","renderVoronoiCellToCanvas","serie","renderLegendToCanvas","getPointFromMouseEvent","_getRelativeCursor","getRelativeCursor","isCursorInRect","pointIndex","handleMouseHover","ref","mergeRefs","cursor","LineCanvas","forwardRef","ResponsiveLineCanvas","ResponsiveWrapper"],"mappings":"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"}