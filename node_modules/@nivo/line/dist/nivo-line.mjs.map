{"version":3,"file":"nivo-line.mjs","sources":["../src/PointTooltip.tsx","../src/defaults.ts","../src/SliceTooltip.tsx","../src/hooks.ts","../src/Areas.tsx","../src/LinesItem.tsx","../src/Lines.tsx","../src/SlicesItem.tsx","../src/Slices.tsx","../src/Points.tsx","../src/Mesh.tsx","../src/Line.tsx","../src/ResponsiveLine.tsx","../src/LineCanvas.tsx","../src/ResponsiveLineCanvas.tsx","../src/types.ts"],"sourcesContent":["import { memo } from 'react'\nimport { BasicTooltip } from '@nivo/tooltip'\nimport { LineSeries, PointTooltipProps } from './types'\n\nexport const NonMemoizedPointTooltip = <Series extends LineSeries>({\n    point,\n}: PointTooltipProps<Series>) => {\n    return (\n        <BasicTooltip\n            id={\n                <span>\n                    x: <strong>{point.data.xFormatted}</strong>, y:{' '}\n                    <strong>{point.data.yFormatted}</strong>\n                </span>\n            }\n            enableChip={true}\n            color={point.seriesColor}\n        />\n    )\n}\n\nexport const PointTooltip = memo(NonMemoizedPointTooltip)\n","import {\n    CommonLineProps,\n    LineSvgPropsWithDefaults,\n    LineCanvasPropsWithDefaults,\n    DefaultSeries,\n    LineLayerId,\n} from './types'\nimport { PointTooltip } from './PointTooltip'\nimport { SliceTooltip } from './SliceTooltip'\n\nexport const commonDefaultProps: Omit<\n    CommonLineProps<DefaultSeries>,\n    | 'data'\n    | 'xFormat'\n    | 'yFormat'\n    | 'layers'\n    | 'width'\n    | 'height'\n    | 'margin'\n    | 'theme'\n    | 'pointSymbol'\n    | 'gridXValues'\n    | 'gridYValues'\n    | 'axisTop'\n    | 'axisRight'\n    | 'onMouseEnter'\n    | 'onMouseMove'\n    | 'onMouseLeave'\n    | 'onMouseDown'\n    | 'onMouseUp'\n    | 'onClick'\n    | 'onDoubleClick'\n    | 'onTouchStart'\n    | 'onTouchMove'\n    | 'onTouchEnd'\n> & {\n    layers: LineLayerId[]\n} = {\n    xScale: {\n        type: 'point',\n    },\n    yScale: {\n        type: 'linear',\n        min: 0,\n        max: 'auto',\n    },\n    curve: 'linear',\n    colors: { scheme: 'nivo' },\n    lineWidth: 2,\n    layers: [\n        'grid',\n        'markers',\n        'axes',\n        'areas',\n        'crosshair',\n        'lines',\n        'points',\n        'slices',\n        'mesh',\n        'legends',\n    ],\n    enablePoints: true,\n    pointSize: 6,\n    pointColor: { from: 'series.color' },\n    pointBorderWidth: 0,\n    pointBorderColor: { theme: 'background' },\n    enableArea: false,\n    areaBaselineValue: 0,\n    areaOpacity: 0.2,\n    enableGridX: true,\n    enableGridY: true,\n    legends: [],\n    isInteractive: true,\n    tooltip: PointTooltip,\n    sliceTooltip: SliceTooltip,\n    debugMesh: false,\n    renderWrapper: true,\n}\n\nexport const svgDefaultProps: Omit<\n    LineSvgPropsWithDefaults<DefaultSeries>,\n    'data' | 'width' | 'height' | 'margin' | 'theme'\n> = {\n    ...commonDefaultProps,\n    defs: [],\n    fill: [],\n    enablePointLabel: false,\n    pointLabel: 'data.yFormatted',\n    areaBlendMode: 'normal',\n    axisBottom: {},\n    axisLeft: {},\n    useMesh: false,\n    enableSlices: false,\n    debugSlices: false,\n    enableCrosshair: true,\n    crosshairType: 'bottom-left',\n    enableTouchCrosshair: false,\n    initialHiddenIds: [],\n    animate: true,\n    motionConfig: 'gentle',\n    role: 'img',\n    isFocusable: false,\n}\n\nexport const canvasDefaultProps: Omit<\n    LineCanvasPropsWithDefaults<DefaultSeries>,\n    'data' | 'width' | 'height' | 'margin' | 'theme'\n> = {\n    ...commonDefaultProps,\n    pixelRatio: typeof window !== 'undefined' ? (window.devicePixelRatio ?? 1) : 1,\n    axisBottom: {},\n    axisLeft: {},\n}\n","import { memo } from 'react'\nimport { useTheme } from '@nivo/theming'\nimport { Chip, TableTooltip } from '@nivo/tooltip'\nimport { LineSeries, SliceTooltipProps } from './types'\n\nexport const NonMemoizedSliceTooltip = <Series extends LineSeries>({\n    slice,\n    axis,\n}: SliceTooltipProps<Series>) => {\n    const theme = useTheme()\n    const otherAxis = axis === 'x' ? 'y' : 'x'\n\n    return (\n        <TableTooltip\n            rows={slice.points.map(point => [\n                <Chip key=\"chip\" color={point.seriesColor} style={theme.tooltip.chip} />,\n                point.seriesId,\n                <span key=\"value\" style={theme.tooltip.tableCellValue}>\n                    {point.data[`${otherAxis}Formatted`]}\n                </span>,\n            ])}\n        />\n    )\n}\n\nexport const SliceTooltip = memo(NonMemoizedSliceTooltip)\n","import { useCallback, useMemo, useState } from 'react'\nimport { area, line } from 'd3-shape'\nimport uniqueId from 'lodash/uniqueId.js'\nimport { curveFromProp, useValueFormatter } from '@nivo/core'\nimport { useTheme } from '@nivo/theming'\nimport {\n    useOrdinalColorScale,\n    useInheritedColor,\n    OrdinalColorScaleConfig,\n    InheritedColorConfig,\n} from '@nivo/colors'\nimport { computeXYScalesForSeries } from '@nivo/scales'\nimport { commonDefaultProps, svgDefaultProps } from './defaults'\nimport {\n    LineSeries,\n    CommonLineProps,\n    DataProps,\n    InferX,\n    InferY,\n    InferSeriesId,\n    LineSvgProps,\n    LineGenerator,\n    AreaGenerator,\n    AllowedValue,\n    ComputedSeries,\n    Point,\n    SliceData,\n    PointColorContext,\n} from './types'\n\nexport function useLineGenerator(curve: CommonLineProps<LineSeries>['curve']): LineGenerator {\n    return useMemo(() => {\n        return line<{\n            x: number\n            y: number\n        }>()\n            .defined(d => d.x !== null && d.y !== null)\n            .x(d => d.x)\n            .y(d => d.y)\n            .curve(curveFromProp(curve))\n    }, [curve])\n}\n\nexport function useAreaGenerator<Y extends AllowedValue>({\n    curve,\n    yScale,\n    areaBaselineValue,\n}: {\n    curve: CommonLineProps<LineSeries>['curve']\n    yScale: (y: Y) => number\n    areaBaselineValue: Y\n}): AreaGenerator {\n    return useMemo(() => {\n        return area<{\n            x: number\n            y: number\n        }>()\n            .defined(d => d.x !== null && d.y !== null)\n            .x(d => d.x)\n            .y1(d => d.y)\n            .curve(curveFromProp(curve))\n            .y0(yScale(areaBaselineValue))\n    }, [curve, yScale, areaBaselineValue])\n}\n\nfunction usePoints<Series extends LineSeries>({\n    series,\n    getPointColor,\n    getPointBorderColor,\n    formatX,\n    formatY,\n}: {\n    series: ComputedSeries<Series>[]\n    getPointColor: (context: PointColorContext<Series>) => string\n    getPointBorderColor: (point: Omit<Point<Series>, 'borderColor'>) => string\n    formatX: (x: InferX<Series>) => string\n    formatY: (y: InferY<Series>) => string\n}) {\n    return useMemo(() => {\n        return series.reduce((acc, seriesItem, seriesIndex) => {\n            return [\n                ...acc,\n                ...seriesItem.data\n                    .filter(datum => datum.position.x !== null && datum.position.y !== null)\n                    .map((datum, indexInSeries) => {\n                        const point: Omit<Point<Series>, 'color' | 'borderColor'> & {\n                            color?: string\n                            borderColor?: string\n                        } = {\n                            id: `${seriesItem.id}.${indexInSeries}`,\n                            indexInSeries,\n                            absIndex: acc.length + indexInSeries,\n                            seriesIndex,\n                            seriesId: seriesItem.id,\n                            seriesColor: seriesItem.color,\n                            x: datum.position.x,\n                            y: datum.position.y,\n                            data: {\n                                ...datum.data,\n                                xFormatted: formatX(datum.data.x as InferX<Series>),\n                                yFormatted: formatY(datum.data.y as InferY<Series>),\n                            },\n                        }\n                        point.color = getPointColor({\n                            series: seriesItem,\n                            point: point as Omit<Point<Series>, 'color' | 'borderColor'>,\n                        })\n                        point.borderColor = getPointBorderColor(\n                            point as Omit<Point<Series>, 'borderColor'>\n                        )\n\n                        return point as Point<Series>\n                    }),\n            ]\n        }, [] as Point<Series>[])\n    }, [series, getPointColor, getPointBorderColor, formatX, formatY])\n}\n\nexport const useSlices = <Series extends LineSeries>({\n    componentId,\n    enableSlices,\n    points,\n    width,\n    height,\n}: {\n    componentId: string\n    enableSlices: Exclude<LineSvgProps<Series>['enableSlices'], undefined>\n    points: Point<Series>[]\n    width: number\n    height: number\n}) => {\n    return useMemo(() => {\n        if (enableSlices === 'x') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.x)) map.set(point.x, [point])\n                else map.get(point.x).push(point)\n            })\n\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([x, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let x0\n                    if (!prevSlice) x0 = x\n                    else x0 = x - (x - prevSlice[0]) / 2\n\n                    let sliceWidth\n                    if (!nextSlice) sliceWidth = width - x0\n                    else sliceWidth = x - x0 + (nextSlice[0] - x) / 2\n\n                    return {\n                        id: `slice:${componentId}:${x}`,\n                        x0,\n                        x,\n                        y0: 0,\n                        y: 0,\n                        width: sliceWidth,\n                        height,\n                        points: slicePoints.reverse(),\n                    } as SliceData<Series>\n                })\n        } else if (enableSlices === 'y') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.y)) map.set(point.y, [point])\n                else map.get(point.y).push(point)\n            })\n\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([y, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let y0\n                    if (!prevSlice) y0 = y\n                    else y0 = y - (y - prevSlice[0]) / 2\n\n                    let sliceHeight\n                    if (!nextSlice) sliceHeight = height - y0\n                    else sliceHeight = y - y0 + (nextSlice[0] - y) / 2\n\n                    return {\n                        id: y,\n                        x0: 0,\n                        x: 0,\n                        y0,\n                        y,\n                        width,\n                        height: sliceHeight,\n                        points: slicePoints.reverse(),\n                    } as SliceData<Series>\n                })\n        }\n\n        return []\n    }, [componentId, enableSlices, height, points, width])\n}\n\nexport const LINE_UNIQUE_ID_PREFIX = 'line'\n\nexport const useLine = <Series extends LineSeries>({\n    data,\n    xScale: xScaleSpec = commonDefaultProps.xScale,\n    xFormat,\n    yScale: yScaleSpec = commonDefaultProps.yScale,\n    yFormat,\n    width,\n    height,\n    colors = commonDefaultProps.colors as OrdinalColorScaleConfig<Series>,\n    curve = commonDefaultProps.curve,\n    areaBaselineValue = commonDefaultProps.areaBaselineValue as InferY<Series>,\n    pointColor = commonDefaultProps.pointColor as InheritedColorConfig<PointColorContext<Series>>,\n    pointBorderColor = commonDefaultProps.pointBorderColor as InheritedColorConfig<\n        Omit<Point<Series>, 'borderColor'>\n    >,\n    enableSlices = svgDefaultProps.enableSlices as Exclude<\n        LineSvgProps<Series>['enableSlices'],\n        undefined\n    >,\n    initialHiddenIds = svgDefaultProps.initialHiddenIds as InferSeriesId<Series>[],\n}: DataProps<Series> &\n    Pick<\n        CommonLineProps<Series>,\n        | 'xScale'\n        | 'yScale'\n        | 'colors'\n        | 'curve'\n        | 'areaBaselineValue'\n        | 'pointColor'\n        | 'pointBorderColor'\n    > & {\n        xFormat?: CommonLineProps<Series>['xFormat']\n        yFormat?: CommonLineProps<Series>['yFormat']\n    } & Pick<LineSvgProps<Series>, 'enableSlices' | 'initialHiddenIds'> & {\n        width: number\n        height: number\n    }): {\n    legendData: {\n        id: InferSeriesId<Series>\n        label: string\n        color: string\n        hidden: boolean\n    }[]\n    toggleSeries: (id: InferSeriesId<Series>) => void\n    lineGenerator: LineGenerator\n    areaGenerator: AreaGenerator\n    getColor: (series: Series) => string\n    series: ComputedSeries<Series>[]\n    xScale: (x: InferX<Series>) => number\n    yScale: (y: InferY<Series>) => number\n    slices: SliceData<Series>[]\n    points: Point<Series>[]\n} => {\n    const [componentId] = useState(uniqueId(LINE_UNIQUE_ID_PREFIX))\n    const formatX = useValueFormatter(xFormat)\n    const formatY = useValueFormatter(yFormat)\n    const getColor = useOrdinalColorScale(colors, 'id')\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n    const [hiddenIds, setHiddenIds] = useState(initialHiddenIds ?? [])\n\n    const {\n        xScale,\n        yScale,\n        series: rawSeries,\n    } = useMemo(\n        () =>\n            computeXYScalesForSeries<Series, Series['data'][number]>(\n                data.filter(item => hiddenIds.indexOf(item.id as InferSeriesId<Series>) === -1),\n                xScaleSpec,\n                yScaleSpec,\n                width,\n                height\n            ),\n        [data, hiddenIds, xScaleSpec, yScaleSpec, width, height]\n    )\n\n    const { legendData, series } = useMemo(() => {\n        const dataWithColor = data.map(seriesItem => ({\n            id: seriesItem.id as InferSeriesId<Series>,\n            label: `${seriesItem.id}`,\n            color: getColor(seriesItem),\n        }))\n\n        const series = dataWithColor\n            .map(datum => ({\n                ...rawSeries.find(seriesItem => seriesItem.id === datum.id)!,\n                color: datum.color,\n            }))\n            .filter(item => Boolean(item.id)) as unknown as ComputedSeries<Series>[]\n\n        const legendData = dataWithColor\n            .map(item => ({\n                ...item,\n                hidden: !series.find(seriesItem => seriesItem.id === item.id),\n            }))\n            .reverse()\n\n        return { legendData, series }\n    }, [data, rawSeries, getColor])\n\n    const toggleSeries = useCallback((id: InferSeriesId<Series>) => {\n        setHiddenIds(state =>\n            state.indexOf(id) > -1 ? state.filter(item => item !== id) : [...state, id]\n        )\n    }, [])\n\n    const points = usePoints<Series>({\n        series,\n        getPointColor,\n        getPointBorderColor,\n        formatX,\n        formatY,\n    })\n\n    const slices = useSlices<Series>({\n        componentId,\n        enableSlices,\n        points,\n        width,\n        height,\n    })\n\n    const lineGenerator = useLineGenerator(curve)\n    const areaGenerator = useAreaGenerator<InferY<Series>>({\n        curve,\n        yScale: yScale as (y: InferY<Series>) => number,\n        areaBaselineValue,\n    })\n\n    return {\n        legendData,\n        toggleSeries,\n        lineGenerator,\n        areaGenerator,\n        getColor,\n        series,\n        xScale: xScale as (x: InferX<Series>) => number,\n        yScale: yScale as (y: InferY<Series>) => number,\n        slices,\n        points,\n    }\n}\n","import { memo } from 'react'\nimport { useSpring, animated } from '@react-spring/web'\nimport { CssMixBlendMode, useAnimatedPath, useMotionConfig } from '@nivo/core'\nimport { LineSeries, ComputedSeries, AreaGenerator } from './types'\n\nconst AreaPath = ({\n    areaBlendMode,\n    areaOpacity,\n    color,\n    fill,\n    path,\n}: {\n    areaBlendMode: CssMixBlendMode\n    areaOpacity: number\n    color: string\n    fill?: string\n    path: string\n}) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedPath = useAnimatedPath(path)\n    const animatedProps = useSpring({\n        color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            fill={fill ? fill : animatedProps.color}\n            fillOpacity={areaOpacity}\n            strokeWidth={0}\n            style={{\n                mixBlendMode: areaBlendMode,\n            }}\n        />\n    )\n}\n\nconst NonMemoizedAreas = <Series extends LineSeries>({\n    areaGenerator,\n    areaOpacity,\n    areaBlendMode,\n    series,\n}: {\n    areaGenerator: AreaGenerator\n    areaOpacity: number\n    areaBlendMode: CssMixBlendMode\n    series: readonly ComputedSeries<Series>[]\n}) => {\n    const reversedSeries = series.slice(0).reverse()\n\n    return (\n        <g>\n            {reversedSeries.map(seriesItem => (\n                <AreaPath\n                    key={`${seriesItem.id}`}\n                    path={areaGenerator(seriesItem.data.map(d => d.position))!}\n                    {...{ areaOpacity, areaBlendMode, ...seriesItem }}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport const Areas = memo(NonMemoizedAreas) as typeof NonMemoizedAreas\n","import { memo, useMemo } from 'react'\nimport { animated } from '@react-spring/web'\nimport { useAnimatedPath } from '@nivo/core'\nimport { LineGenerator } from './types'\n\nexport const NonMemoizedLinesItem = ({\n    lineGenerator,\n    points,\n    color,\n    thickness,\n}: {\n    lineGenerator: LineGenerator\n    points: { x: number; y: number }[]\n    color: string\n    thickness: number\n}) => {\n    const path = useMemo(() => lineGenerator(points), [lineGenerator, points])\n    const animatedPath = useAnimatedPath(path!)\n\n    return <animated.path d={animatedPath} fill=\"none\" strokeWidth={thickness} stroke={color} />\n}\n\nexport const LinesItem = memo(NonMemoizedLinesItem) as typeof NonMemoizedLinesItem\n","import { memo } from 'react'\nimport { LineSeries, ComputedSeries, LineGenerator } from './types'\nimport { LinesItem } from './LinesItem'\n\nexport const NonMemoizedLines = <Series extends LineSeries>({\n    series,\n    lineGenerator,\n    lineWidth,\n}: {\n    series: readonly ComputedSeries<Series>[]\n    lineGenerator: LineGenerator\n    lineWidth: number\n}) => {\n    return (\n        <>\n            {series\n                .slice(0)\n                .reverse()\n                .map(({ id, data, color }) => (\n                    <LinesItem\n                        key={id}\n                        points={data.map(d => d.position)}\n                        lineGenerator={lineGenerator}\n                        color={color}\n                        thickness={lineWidth}\n                    />\n                ))}\n        </>\n    )\n}\n\nexport const Lines = memo(NonMemoizedLines) as typeof NonMemoizedLines\n","import { createElement, memo, useCallback, MouseEvent, TouchEvent } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\nimport { LineSeries, SliceData, CommonLineProps, LineSvgProps } from './types'\n\nexport const NonMemoizedSlicesItem = <Series extends LineSeries>({\n    slice,\n    slices,\n    axis,\n    debug,\n    tooltip,\n    isCurrent,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}: {\n    slice: SliceData<Series>\n    slices: readonly SliceData<Series>[]\n    axis: Exclude<LineSvgProps<Series>['enableSlices'], undefined | false>\n    debug: boolean\n    tooltip: CommonLineProps<Series>['sliceTooltip']\n    isCurrent: boolean\n    setCurrent: (slice: SliceData<Series> | null) => void\n    onMouseEnter?: CommonLineProps<Series>['onMouseEnter']\n    onMouseMove?: CommonLineProps<Series>['onMouseMove']\n    onMouseLeave?: CommonLineProps<Series>['onMouseLeave']\n    onMouseDown?: CommonLineProps<Series>['onMouseDown']\n    onMouseUp?: CommonLineProps<Series>['onMouseUp']\n    onClick?: CommonLineProps<Series>['onClick']\n    onDoubleClick?: CommonLineProps<Series>['onDoubleClick']\n    onTouchStart?: CommonLineProps<Series>['onTouchStart']\n    onTouchMove?: CommonLineProps<Series>['onTouchMove']\n    onTouchEnd?: CommonLineProps<Series>['onTouchEnd']\n}) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onMouseEnter?.(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, setCurrent, onMouseEnter]\n    )\n\n    const handleMouseMove = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            onMouseMove?.(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            hideTooltip()\n            setCurrent(null)\n            onMouseLeave?.(slice, event)\n        },\n        [hideTooltip, setCurrent, onMouseLeave, slice]\n    )\n\n    const handleMouseDown = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onMouseDown?.(slice, event)\n        },\n        [slice, onMouseDown]\n    )\n\n    const handleMouseUp = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onMouseUp?.(slice, event)\n        },\n        [slice, onMouseUp]\n    )\n\n    const handleClick = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onClick?.(slice, event)\n        },\n        [slice, onClick]\n    )\n\n    const handleDoubleClick = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onDoubleClick?.(slice, event)\n        },\n        [slice, onDoubleClick]\n    )\n\n    const handeOnTouchStart = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onTouchStart?.(slice, event)\n        },\n        [axis, onTouchStart, setCurrent, showTooltipFromEvent, slice, tooltip]\n    )\n\n    const handeOnTouchMove = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            // This event will be locked to the element that was touched originally\n            // We find the element that is currently being \"hovered over\" by getting the element at the touch point\n            const touchPoint = event.touches[0]\n            const touchingElement = document.elementFromPoint(\n                touchPoint.clientX,\n                touchPoint.clientY\n            )\n            // Is this a nivo ref?\n            const touchingSliceId = touchingElement?.getAttribute('data-ref')\n            if (touchingSliceId) {\n                // Is this a slice for this graph?\n                const slice = slices.find(slice => slice.id === touchingSliceId)\n                if (slice) {\n                    showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n                    setCurrent(slice)\n                }\n            }\n\n            // Note here, this will pass the original slice, not the one we found\n            // But this can be found with document.elementFromPoint()\n            onTouchMove?.(slice, event)\n        },\n        [axis, onTouchMove, setCurrent, showTooltipFromEvent, slice, slices, tooltip]\n    )\n\n    const handleOnTouchEnd = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            hideTooltip()\n            setCurrent(null)\n            onTouchEnd?.(slice, event)\n        },\n        [hideTooltip, setCurrent, onTouchEnd, slice]\n    )\n\n    return (\n        <rect\n            x={slice.x0}\n            y={slice.y0}\n            width={slice.width}\n            height={slice.height}\n            stroke=\"red\"\n            strokeWidth={debug ? 1 : 0}\n            strokeOpacity={0.75}\n            fill=\"red\"\n            fillOpacity={isCurrent && debug ? 0.35 : 0}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onMouseDown={handleMouseDown}\n            onMouseUp={handleMouseUp}\n            onClick={handleClick}\n            onDoubleClick={handleDoubleClick}\n            onTouchStart={handeOnTouchStart}\n            onTouchMove={handeOnTouchMove}\n            onTouchEnd={handleOnTouchEnd}\n            data-ref={slice.id}\n        />\n    )\n}\n\nexport const SlicesItem = memo(NonMemoizedSlicesItem) as typeof NonMemoizedSlicesItem\n","import { memo } from 'react'\nimport { SlicesItem } from './SlicesItem'\nimport { LineSeries, SliceData, CommonLineProps, LineSvgProps } from './types'\n\nexport const NonMemoizedSlices = <Series extends LineSeries>({\n    slices,\n    axis,\n    debug,\n    tooltip,\n    current,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}: {\n    slices: readonly SliceData<Series>[]\n    axis: Exclude<LineSvgProps<Series>['enableSlices'], undefined | false>\n    debug: boolean\n    tooltip: CommonLineProps<Series>['sliceTooltip']\n    current: SliceData<Series> | null\n    setCurrent: (slice: SliceData<Series> | null) => void\n    onMouseEnter?: CommonLineProps<Series>['onMouseEnter']\n    onMouseMove?: CommonLineProps<Series>['onMouseMove']\n    onMouseLeave?: CommonLineProps<Series>['onMouseLeave']\n    onMouseDown?: CommonLineProps<Series>['onMouseDown']\n    onMouseUp?: CommonLineProps<Series>['onMouseUp']\n    onClick?: CommonLineProps<Series>['onClick']\n    onDoubleClick?: CommonLineProps<Series>['onDoubleClick']\n    onTouchStart?: CommonLineProps<Series>['onTouchStart']\n    onTouchMove?: CommonLineProps<Series>['onTouchMove']\n    onTouchEnd?: CommonLineProps<Series>['onTouchEnd']\n}) => {\n    return (\n        <>\n            {slices.map(slice => (\n                <SlicesItem<Series>\n                    key={slice.id}\n                    slice={slice}\n                    slices={slices}\n                    axis={axis}\n                    debug={debug}\n                    tooltip={tooltip}\n                    setCurrent={setCurrent}\n                    isCurrent={current !== null && current.id === slice.id}\n                    onMouseEnter={onMouseEnter}\n                    onMouseMove={onMouseMove}\n                    onMouseLeave={onMouseLeave}\n                    onMouseDown={onMouseDown}\n                    onMouseUp={onMouseUp}\n                    onClick={onClick}\n                    onDoubleClick={onDoubleClick}\n                    onTouchStart={onTouchStart}\n                    onTouchMove={onTouchMove}\n                    onTouchEnd={onTouchEnd}\n                />\n            ))}\n        </>\n    )\n}\n\nexport const Slices = memo(NonMemoizedSlices) as typeof NonMemoizedSlices\n","import { createElement, memo } from 'react'\n// @ts-expect-error no types\nimport { getLabelGenerator } from '@nivo/core'\nimport { DotsItem, Margin } from '@nivo/core'\nimport { useTooltip } from '@nivo/tooltip'\nimport { LineSeries, LineSvgPropsWithDefaults, Point } from './types'\n\nconst NonMemoizedPoints = <Series extends LineSeries>({\n    points,\n    symbol,\n    size,\n    borderWidth,\n    enableLabel,\n    label,\n    labelYOffset,\n    isFocusable,\n    setCurrentPoint,\n    tooltip,\n    margin,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n    ariaHidden,\n    ariaDisabled,\n}: {\n    points: readonly Point<Series>[]\n    symbol: LineSvgPropsWithDefaults<Series>['pointSymbol']\n    size: number\n    borderWidth: LineSvgPropsWithDefaults<Series>['pointBorderWidth']\n    enableLabel: LineSvgPropsWithDefaults<Series>['enablePointLabel']\n    label: LineSvgPropsWithDefaults<Series>['pointLabel']\n    labelYOffset: LineSvgPropsWithDefaults<Series>['pointLabelYOffset']\n    isFocusable: LineSvgPropsWithDefaults<Series>['isFocusable']\n    setCurrentPoint: (point: Point<Series> | null) => void\n    tooltip: LineSvgPropsWithDefaults<Series>['tooltip']\n    margin: Margin\n    ariaLabel: LineSvgPropsWithDefaults<Series>['pointAriaLabel']\n    ariaLabelledBy: LineSvgPropsWithDefaults<Series>['pointAriaLabelledBy']\n    ariaDescribedBy: LineSvgPropsWithDefaults<Series>['pointAriaDescribedBy']\n    ariaHidden: LineSvgPropsWithDefaults<Series>['pointAriaHidden']\n    ariaDisabled: LineSvgPropsWithDefaults<Series>['pointAriaDisabled']\n}) => {\n    const getLabel = getLabelGenerator(label)\n\n    const { showTooltipAt, hideTooltip } = useTooltip()\n\n    // We sort the points so that the lower series are drawn on top of the higher ones.\n    const mappedPoints = points\n        .slice(0)\n        .sort((a, b) => a.indexInSeries - b.indexInSeries)\n        .sort((a, b) => b.seriesIndex - a.seriesIndex)\n        .map(point => {\n            return {\n                id: point.id,\n                x: point.x,\n                y: point.y,\n                datum: point.data,\n                fill: point.color,\n                stroke: point.borderColor,\n                label: enableLabel ? getLabel(point) : null,\n                ariaLabel: ariaLabel ? ariaLabel(point) : undefined,\n                ariaLabelledBy: ariaLabelledBy ? ariaLabelledBy(point) : undefined,\n                ariaDescribedBy: ariaDescribedBy ? ariaDescribedBy(point) : undefined,\n                ariaHidden: ariaHidden ? ariaHidden(point) : undefined,\n                ariaDisabled: ariaDisabled ? ariaDisabled(point) : undefined,\n                onFocus: isFocusable\n                    ? () => {\n                          setCurrentPoint(point)\n                          showTooltipAt(\n                              createElement(tooltip, { point }),\n                              [margin.left + point.x, margin.top + point.y],\n                              'top'\n                          )\n                      }\n                    : undefined,\n                onBlur: isFocusable\n                    ? () => {\n                          setCurrentPoint(null)\n                          hideTooltip()\n                      }\n                    : undefined,\n            }\n        })\n\n    return (\n        <g>\n            {mappedPoints.map(point => (\n                <DotsItem\n                    key={point.id}\n                    x={point.x}\n                    y={point.y}\n                    datum={point.datum}\n                    symbol={symbol as any}\n                    size={size}\n                    color={point.fill}\n                    borderWidth={borderWidth}\n                    borderColor={point.stroke}\n                    label={point.label}\n                    labelYOffset={labelYOffset}\n                    ariaLabel={point.ariaLabel}\n                    ariaLabelledBy={point.ariaLabelledBy}\n                    ariaDescribedBy={point.ariaDescribedBy}\n                    ariaHidden={point.ariaHidden}\n                    ariaDisabled={point.ariaDisabled}\n                    isFocusable={isFocusable}\n                    onFocus={point.onFocus}\n                    onBlur={point.onBlur}\n                    testId={`line.point.${point.id}`}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport const Points = memo(NonMemoizedPoints) as typeof NonMemoizedPoints\n","import { createElement, memo, useCallback, MouseEvent, TouchEvent } from 'react'\nimport { Margin } from '@nivo/core'\nimport { useTooltip } from '@nivo/tooltip'\nimport { Mesh as BaseMesh } from '@nivo/voronoi'\nimport { LineSeries, Point, LineSvgProps, LineSvgPropsWithDefaults } from './types'\n\nconst NonMemoizedMesh = <Series extends LineSeries>({\n    points,\n    width,\n    height,\n    margin,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    tooltip,\n    debug,\n    enableTouchCrosshair,\n}: {\n    points: Point<Series>[]\n    width: number\n    height: number\n    margin: Margin\n    setCurrent: (point: Point<Series> | null) => void\n    onMouseEnter?: LineSvgProps<Series>['onMouseEnter']\n    onMouseMove?: LineSvgProps<Series>['onMouseMove']\n    onMouseLeave?: LineSvgProps<Series>['onMouseLeave']\n    onMouseDown?: LineSvgProps<Series>['onMouseDown']\n    onMouseUp?: LineSvgProps<Series>['onMouseUp']\n    onClick?: LineSvgProps<Series>['onClick']\n    onDoubleClick?: LineSvgProps<Series>['onDoubleClick']\n    onTouchStart?: LineSvgProps<Series>['onTouchStart']\n    onTouchMove?: LineSvgProps<Series>['onTouchMove']\n    onTouchEnd?: LineSvgProps<Series>['onTouchEnd']\n    tooltip: LineSvgPropsWithDefaults<Series>['tooltip']\n    debug: boolean\n    enableTouchCrosshair: LineSvgPropsWithDefaults<Series>['enableTouchCrosshair']\n}) => {\n    const { showTooltipAt, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseEnter?.(point, event)\n        },\n        [showTooltipAt, tooltip, onMouseEnter, margin]\n    )\n\n    const handleMouseMove = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseMove?.(point, event)\n        },\n        [showTooltipAt, tooltip, margin.left, margin.top, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            hideTooltip()\n            onMouseLeave?.(point, event)\n        },\n        [hideTooltip, onMouseLeave]\n    )\n\n    const handleMouseDown = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            onMouseDown?.(point, event)\n        },\n        [onMouseDown]\n    )\n\n    const handleMouseUp = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            onMouseUp?.(point, event)\n        },\n        [onMouseUp]\n    )\n\n    const handleClick = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            onClick?.(point, event)\n        },\n        [onClick]\n    )\n\n    const handleDoubleClick = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            onDoubleClick?.(point, event)\n        },\n        [onDoubleClick]\n    )\n\n    const handleTouchStart = useCallback(\n        (point: Point<Series>, event: TouchEvent) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchStart?.(point, event)\n        },\n        [margin.left, margin.top, onTouchStart, showTooltipAt, tooltip]\n    )\n\n    const handleTouchMove = useCallback(\n        (point: Point<Series>, event: TouchEvent) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchMove?.(point, event)\n        },\n        [margin.left, margin.top, onTouchMove, showTooltipAt, tooltip]\n    )\n\n    const handleTouchEnd = useCallback(\n        (point: Point<Series>, event: TouchEvent) => {\n            hideTooltip()\n            onTouchEnd?.(point, event)\n        },\n        [onTouchEnd, hideTooltip]\n    )\n\n    return (\n        <BaseMesh<Point<Series>>\n            nodes={points}\n            width={width}\n            height={height}\n            setCurrent={setCurrent}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onMouseDown={handleMouseDown}\n            onMouseUp={handleMouseUp}\n            onClick={handleClick}\n            onDoubleClick={handleDoubleClick}\n            onTouchStart={handleTouchStart}\n            onTouchMove={handleTouchMove}\n            onTouchEnd={handleTouchEnd}\n            enableTouchCrosshair={enableTouchCrosshair}\n            debug={debug}\n        />\n    )\n}\n\nexport const Mesh = memo(NonMemoizedMesh) as typeof NonMemoizedMesh\n","import { Fragment, ReactNode, useState } from 'react'\nimport {\n    // @ts-expect-error no types\n    bindDefs,\n    useDimensions,\n    SvgWrapper,\n    CartesianMarkers,\n    Container,\n    LineCurveFactoryId,\n} from '@nivo/core'\nimport { InheritedColorConfig, OrdinalColorScaleConfig } from '@nivo/colors'\nimport { Axes, Grid } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { Crosshair, CrosshairType } from '@nivo/tooltip'\nimport { AnyScale } from '@nivo/scales'\nimport { useLine } from './hooks'\nimport { Areas } from './Areas'\nimport { Lines } from './Lines'\nimport { Slices } from './Slices'\nimport { Points } from './Points'\nimport { Mesh } from './Mesh'\nimport {\n    LineSeries,\n    InferSeriesId,\n    InferY,\n    LineLayerId,\n    LineSvgProps,\n    Point,\n    PointColorContext,\n    SliceData,\n    LineCustomSvgLayerProps,\n    PointTooltipComponent,\n    SliceTooltipComponent,\n    LineSvgPropsWithDefaults,\n} from './types'\nimport { svgDefaultProps } from './defaults'\n\nfunction InnerLine<Series extends LineSeries>(props: LineSvgProps<Series>) {\n    const {\n        data,\n        xScale: xScaleSpec = svgDefaultProps.xScale,\n        xFormat,\n        yScale: yScaleSpec = svgDefaultProps.yScale,\n        yFormat,\n        curve = svgDefaultProps.curve as LineCurveFactoryId,\n        margin: partialMargin,\n        width,\n        height,\n        colors = svgDefaultProps.colors as OrdinalColorScaleConfig<Series>,\n        lineWidth = svgDefaultProps.lineWidth as number,\n        layers = svgDefaultProps.layers as readonly LineLayerId[],\n        enableArea = svgDefaultProps.enableArea,\n        areaBaselineValue = svgDefaultProps.areaBaselineValue as InferY<Series>,\n        areaOpacity = svgDefaultProps.areaOpacity,\n        areaBlendMode = svgDefaultProps.areaBlendMode,\n        enablePoints = svgDefaultProps.enablePoints,\n        pointSymbol,\n        pointSize = svgDefaultProps.pointSize,\n        pointColor = svgDefaultProps.pointColor as InheritedColorConfig<PointColorContext<Series>>,\n        pointBorderWidth = svgDefaultProps.pointBorderWidth,\n        pointBorderColor = svgDefaultProps.pointBorderColor as InheritedColorConfig<\n            Omit<Point<Series>, 'borderColor'>\n        >,\n        enablePointLabel = svgDefaultProps.enablePointLabel,\n        pointLabel = svgDefaultProps.pointLabel as string,\n        pointLabelYOffset,\n        enableGridX = svgDefaultProps.enableGridX,\n        gridXValues,\n        enableGridY = svgDefaultProps.enableGridY,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom = svgDefaultProps.axisBottom,\n        axisLeft = svgDefaultProps.axisLeft,\n        defs = svgDefaultProps.defs,\n        fill = svgDefaultProps.fill,\n        markers,\n        legends = svgDefaultProps.legends,\n        isInteractive = svgDefaultProps.isInteractive,\n        useMesh = svgDefaultProps.useMesh,\n        debugMesh = svgDefaultProps.debugMesh,\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onMouseDown,\n        onMouseUp,\n        onClick,\n        onDoubleClick,\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd,\n        tooltip = svgDefaultProps.tooltip as PointTooltipComponent<Series>,\n        enableSlices = svgDefaultProps.enableSlices,\n        debugSlices = svgDefaultProps.debugSlices,\n        sliceTooltip = svgDefaultProps.sliceTooltip as SliceTooltipComponent<Series>,\n        enableCrosshair = svgDefaultProps.enableCrosshair,\n        crosshairType = svgDefaultProps.crosshairType as CrosshairType,\n        enableTouchCrosshair = svgDefaultProps.enableTouchCrosshair,\n        role = svgDefaultProps.role,\n        ariaLabel,\n        ariaLabelledBy,\n        ariaDescribedBy,\n        isFocusable = svgDefaultProps.isFocusable,\n        pointAriaLabel,\n        pointAriaLabelledBy,\n        pointAriaDescribedBy,\n        pointAriaHidden,\n        pointAriaDisabled,\n        initialHiddenIds = svgDefaultProps.initialHiddenIds as InferSeriesId<Series>[],\n    } = props\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        legendData,\n        toggleSeries,\n        lineGenerator,\n        areaGenerator,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    } = useLine<Series>({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n        enableSlices,\n        initialHiddenIds,\n    })\n\n    const [currentPoint, setCurrentPoint] = useState<Point<Series> | null>(null)\n    const [currentSlice, setCurrentSlice] = useState<SliceData<Series> | null>(null)\n\n    const layerById: Record<LineLayerId, ReactNode> = {\n        grid: null,\n        markers: null,\n        axes: null,\n        areas: null,\n        crosshair: null,\n        lines: null,\n        points: null,\n        slices: null,\n        mesh: null,\n        legends: null,\n    }\n\n    if (layers.includes('grid') && (enableGridX || enableGridY)) {\n        layerById.grid = (\n            <Grid\n                key=\"grid\"\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? (xScale as AnyScale) : null}\n                yScale={enableGridY ? (yScale as AnyScale) : null}\n                xValues={gridXValues}\n                yValues={gridYValues}\n            />\n        )\n    }\n\n    if (layers.includes('markers') && Array.isArray(markers) && markers.length > 0) {\n        layerById.markers = (\n            <CartesianMarkers\n                key=\"markers\"\n                markers={markers}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={xScale}\n                yScale={yScale}\n            />\n        )\n    }\n\n    if (layers.includes('axes')) {\n        layerById.axes = (\n            <Axes\n                key=\"axes\"\n                xScale={xScale as AnyScale}\n                yScale={yScale as AnyScale}\n                width={innerWidth}\n                height={innerHeight}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        )\n    }\n\n    if (layers.includes('lines')) {\n        layerById.lines = (\n            <Lines<Series>\n                key=\"lines\"\n                series={series}\n                lineGenerator={lineGenerator}\n                lineWidth={lineWidth}\n            />\n        )\n    }\n\n    if (layers.includes('legends') && legends.length > 0) {\n        layerById.legends = (\n            <Fragment key=\"legends\">\n                {legends.map((legend, i) => (\n                    <BoxLegendSvg\n                        key={i}\n                        {...legend}\n                        containerWidth={innerWidth}\n                        containerHeight={innerHeight}\n                        data={legend.data || legendData}\n                        toggleSerie={\n                            legend.toggleSerie\n                                ? (toggleSeries as (id: string | number) => void)\n                                : undefined\n                        }\n                    />\n                ))}\n            </Fragment>\n        )\n    }\n\n    const boundDefs = bindDefs(defs, series, fill)\n\n    if (enableArea) {\n        layerById.areas = (\n            <Areas<Series>\n                key=\"areas\"\n                areaGenerator={areaGenerator}\n                areaOpacity={areaOpacity}\n                areaBlendMode={areaBlendMode}\n                series={series}\n            />\n        )\n    }\n\n    if (isInteractive && enableSlices !== false) {\n        layerById.slices = (\n            <Slices<Series>\n                key=\"slices\"\n                slices={slices}\n                axis={enableSlices}\n                debug={debugSlices}\n                tooltip={sliceTooltip}\n                current={currentSlice}\n                setCurrent={setCurrentSlice}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onMouseDown={onMouseDown}\n                onMouseUp={onMouseUp}\n                onClick={onClick}\n                onDoubleClick={onDoubleClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n            />\n        )\n    }\n\n    if (enablePoints) {\n        layerById.points = (\n            <Points<Series>\n                key=\"points\"\n                points={points}\n                symbol={pointSymbol}\n                size={pointSize}\n                borderWidth={pointBorderWidth}\n                enableLabel={enablePointLabel}\n                label={pointLabel}\n                labelYOffset={pointLabelYOffset}\n                isFocusable={isFocusable}\n                setCurrentPoint={setCurrentPoint}\n                tooltip={tooltip}\n                margin={margin}\n                ariaLabel={pointAriaLabel}\n                ariaLabelledBy={pointAriaLabelledBy}\n                ariaDescribedBy={pointAriaDescribedBy}\n                ariaHidden={pointAriaHidden}\n                ariaDisabled={pointAriaDisabled}\n            />\n        )\n    }\n\n    if (isInteractive && enableCrosshair) {\n        if (currentPoint !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentPoint.x}\n                    y={currentPoint.y}\n                    type={crosshairType}\n                />\n            )\n        }\n        if (currentSlice !== null && enableSlices) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentSlice.x}\n                    y={currentSlice.y}\n                    type={enableSlices}\n                />\n            )\n        }\n    }\n\n    if (isInteractive && useMesh && enableSlices === false) {\n        layerById.mesh = (\n            <Mesh<Series>\n                key=\"mesh\"\n                points={points}\n                width={innerWidth}\n                height={innerHeight}\n                margin={margin}\n                setCurrent={setCurrentPoint}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onMouseDown={onMouseDown}\n                onMouseUp={onMouseUp}\n                onClick={onClick}\n                onDoubleClick={onDoubleClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n                tooltip={tooltip}\n                enableTouchCrosshair={enableTouchCrosshair}\n                debug={debugMesh}\n            />\n        )\n    }\n\n    const customLayerProps: LineCustomSvgLayerProps<Series> = {\n        ...(props as LineSvgPropsWithDefaults<Series>),\n        innerWidth,\n        innerHeight,\n        series,\n        slices,\n        points,\n        xScale,\n        yScale,\n        lineGenerator,\n        areaGenerator,\n        currentPoint,\n        setCurrentPoint,\n        currentSlice,\n        setCurrentSlice,\n    }\n\n    return (\n        <SvgWrapper\n            defs={boundDefs}\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            ariaDescribedBy={ariaDescribedBy}\n            isFocusable={isFocusable}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{layer(customLayerProps)}</Fragment>\n                }\n\n                return layerById[layer]\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport function Line<Series extends LineSeries>({\n    isInteractive = svgDefaultProps.isInteractive,\n    animate = svgDefaultProps.animate,\n    motionConfig = svgDefaultProps.motionConfig,\n    theme,\n    renderWrapper,\n    ...otherProps\n}: LineSvgProps<Series>) {\n    return (\n        <Container\n            {...{\n                animate,\n                isInteractive,\n                motionConfig,\n                renderWrapper,\n                theme,\n            }}\n        >\n            <InnerLine<Series> isInteractive={isInteractive} {...otherProps} />\n        </Container>\n    )\n}\n","import { ResponsiveWrapper } from '@nivo/core'\nimport { Line } from './Line'\nimport { LineSvgProps, LineSeries } from './types'\n\nexport const ResponsiveLine = <Series extends LineSeries>(\n    props: Omit<LineSvgProps<Series>, 'width' | 'height'>\n) => {\n    return (\n        <ResponsiveWrapper>\n            {({ width, height }: { width: number; height: number }) => (\n                <Line<Series> width={width} height={height} {...props} />\n            )}\n        </ResponsiveWrapper>\n    )\n}\n","import {\n    createElement,\n    useRef,\n    useEffect,\n    useState,\n    useCallback,\n    forwardRef,\n    ForwardedRef,\n    MouseEvent,\n    useMemo,\n    ReactElement,\n    Ref,\n} from 'react'\nimport { useDimensions, getRelativeCursor, isCursorInRect, Container, mergeRefs } from '@nivo/core'\nimport { useTheme } from '@nivo/theming'\nimport { renderAxesToCanvas, renderGridLinesToCanvas } from '@nivo/axes'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useTooltip } from '@nivo/tooltip'\nimport { useVoronoiMesh, renderVoronoiToCanvas, renderVoronoiCellToCanvas } from '@nivo/voronoi'\nimport { OrdinalColorScaleConfig, InheritedColorConfig } from '@nivo/colors'\nimport { useLine } from './hooks'\nimport {\n    InferY,\n    LineCanvasProps,\n    LineLayerId,\n    LineSeries,\n    PointTooltipComponent,\n    Point,\n    LineCustomCanvasLayerProps,\n    PointColorContext,\n} from './types'\nimport { canvasDefaultProps } from './defaults'\nimport { AnyScale } from '@nivo/scales'\n\nconst InnerLineCanvas = <Series extends LineSeries>({\n    width,\n    height,\n    margin: partialMargin,\n    pixelRatio = canvasDefaultProps.pixelRatio,\n\n    data,\n    xScale: xScaleSpec = canvasDefaultProps.xScale,\n    xFormat,\n    yScale: yScaleSpec = canvasDefaultProps.yScale,\n    yFormat,\n    curve = canvasDefaultProps.curve,\n\n    layers = canvasDefaultProps.layers as LineLayerId[],\n\n    colors = canvasDefaultProps.colors as OrdinalColorScaleConfig<Series>,\n    lineWidth = canvasDefaultProps.lineWidth,\n\n    enableArea = canvasDefaultProps.enableArea,\n    areaBaselineValue = canvasDefaultProps.areaBaselineValue as InferY<Series>,\n    areaOpacity = canvasDefaultProps.areaOpacity,\n\n    enablePoints = canvasDefaultProps.enablePoints,\n    pointSize = canvasDefaultProps.pointSize,\n    pointColor = canvasDefaultProps.pointColor as InheritedColorConfig<PointColorContext<Series>>,\n    pointBorderWidth = canvasDefaultProps.pointBorderWidth,\n    pointBorderColor = canvasDefaultProps.pointBorderColor as InheritedColorConfig<\n        Omit<Point<Series>, 'borderColor'>\n    >,\n\n    enableGridX = canvasDefaultProps.enableGridX,\n    gridXValues,\n    enableGridY = canvasDefaultProps.enableGridY,\n    gridYValues,\n    axisTop,\n    axisRight,\n    axisBottom = canvasDefaultProps.axisBottom,\n    axisLeft = canvasDefaultProps.axisLeft,\n\n    legends = canvasDefaultProps.legends,\n\n    isInteractive = canvasDefaultProps.isInteractive,\n    debugMesh = canvasDefaultProps.debugMesh,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    tooltip = canvasDefaultProps.tooltip as PointTooltipComponent<Series>,\n    forwardedRef,\n}: Omit<LineCanvasProps<Series>, 'renderWrapper' | 'theme'> & {\n    forwardedRef: Ref<HTMLCanvasElement>\n}) => {\n    const canvasEl = useRef<HTMLCanvasElement | null>(null)\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n    const theme = useTheme()\n    const [currentPoint, setCurrentPoint] = useState<Point<Series> | null>(null)\n\n    const { lineGenerator, areaGenerator, series, xScale, yScale, points } = useLine<Series>({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n    })\n\n    const customLayerProps: LineCustomCanvasLayerProps<Series> = useMemo(\n        () => ({\n            innerWidth,\n            innerHeight,\n            series,\n            points,\n            xScale,\n            yScale,\n            lineWidth,\n            lineGenerator,\n            areaGenerator,\n            currentPoint,\n            setCurrentPoint,\n        }),\n        [\n            innerWidth,\n            innerHeight,\n            series,\n            points,\n            xScale,\n            yScale,\n            lineWidth,\n            lineGenerator,\n            areaGenerator,\n            currentPoint,\n            setCurrentPoint,\n        ]\n    )\n\n    const { delaunay, voronoi } = useVoronoiMesh({\n        points,\n        width: innerWidth,\n        height: innerHeight,\n        debug: debugMesh,\n    })\n\n    useEffect(() => {\n        if (canvasEl.current === null) return\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        const ctx = canvasEl.current.getContext('2d')!\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        layers.forEach(layer => {\n            if (typeof layer === 'function') {\n                layer(ctx, customLayerProps)\n            }\n\n            const gridLineWidth = theme.grid.line.strokeWidth ?? 0\n            if (layer === 'grid' && typeof gridLineWidth !== 'string' && gridLineWidth > 0) {\n                ctx.lineWidth = gridLineWidth\n                ctx.strokeStyle = theme.grid.line.stroke as string\n\n                if (enableGridX) {\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: xScale as AnyScale,\n                        axis: 'x',\n                        values: gridXValues,\n                    })\n                }\n\n                if (enableGridY) {\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: yScale as AnyScale,\n                        axis: 'y',\n                        values: gridYValues,\n                    })\n                }\n            }\n\n            if (layer === 'axes') {\n                renderAxesToCanvas(ctx, {\n                    xScale: xScale as AnyScale,\n                    yScale: yScale as AnyScale,\n                    width: innerWidth,\n                    height: innerHeight,\n                    top: axisTop,\n                    right: axisRight,\n                    bottom: axisBottom,\n                    left: axisLeft,\n                    theme,\n                })\n            }\n\n            if (layer === 'areas' && enableArea === true) {\n                ctx.save()\n                ctx.globalAlpha = areaOpacity\n\n                areaGenerator.context(ctx)\n                for (let i = series.length - 1; i >= 0; i--) {\n                    ctx.fillStyle = series[i].color\n                    ctx.beginPath()\n                    areaGenerator(series[i].data.map(d => d.position))\n                    ctx.fill()\n                }\n\n                ctx.restore()\n            }\n\n            if (layer === 'lines') {\n                lineGenerator.context(ctx)\n                series.forEach(seriesItem => {\n                    ctx.strokeStyle = seriesItem.color\n                    ctx.lineWidth = lineWidth\n                    ctx.beginPath()\n                    lineGenerator(seriesItem.data.map(d => d.position))\n                    ctx.stroke()\n                })\n            }\n\n            if (layer === 'points' && enablePoints === true && pointSize > 0) {\n                points.forEach(point => {\n                    ctx.fillStyle = point.color\n                    ctx.beginPath()\n                    ctx.arc(point.x, point.y, pointSize / 2, 0, 2 * Math.PI)\n                    ctx.fill()\n\n                    if (pointBorderWidth > 0) {\n                        ctx.strokeStyle = point.borderColor\n                        ctx.lineWidth = pointBorderWidth\n                        ctx.stroke()\n                    }\n                })\n            }\n\n            if (layer === 'mesh' && debugMesh === true && voronoi !== undefined) {\n                renderVoronoiToCanvas(ctx, voronoi)\n                if (currentPoint) {\n                    renderVoronoiCellToCanvas(ctx, voronoi, currentPoint.absIndex)\n                }\n            }\n\n            if (layer === 'legends') {\n                const legendData = series\n                    .map(serie => ({\n                        id: serie.id,\n                        label: serie.id,\n                        color: serie.color,\n                    }))\n                    .reverse()\n\n                legends.forEach(legend => {\n                    renderLegendToCanvas(ctx, {\n                        ...legend,\n                        data: legend.data || legendData,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        theme,\n                    })\n                })\n            }\n        })\n    }, [\n        canvasEl,\n        innerWidth,\n        outerWidth,\n        innerHeight,\n        outerHeight,\n        margin.left,\n        margin.top,\n        pixelRatio,\n        layers,\n        theme,\n        lineGenerator,\n        series,\n        xScale,\n        yScale,\n        enableGridX,\n        gridXValues,\n        enableGridY,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom,\n        axisLeft,\n        legends,\n        points,\n        enablePoints,\n        pointSize,\n        pointBorderWidth,\n        currentPoint,\n        customLayerProps,\n        debugMesh,\n        enableArea,\n        areaGenerator,\n        areaOpacity,\n        lineWidth,\n        voronoi,\n    ])\n\n    const getPointFromMouseEvent = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (!canvasEl.current) return null\n\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n            if (!isCursorInRect(margin.left, margin.top, innerWidth, innerHeight, x, y)) return null\n\n            const pointIndex = delaunay.find(x - margin.left, y - margin.top)\n            return points[pointIndex]\n        },\n        [canvasEl, margin, innerWidth, innerHeight, delaunay, points]\n    )\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseHover = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            const point = getPointFromMouseEvent(event)\n            setCurrentPoint(point)\n\n            if (point) {\n                showTooltipFromEvent(createElement(tooltip, { point }), event)\n            } else {\n                hideTooltip()\n            }\n        },\n        [getPointFromMouseEvent, setCurrentPoint, showTooltipFromEvent, hideTooltip, tooltip]\n    )\n\n    const handleMouseLeave = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            hideTooltip()\n            setCurrentPoint(null)\n            if (currentPoint) onMouseLeave?.(currentPoint, event)\n        },\n        [hideTooltip, setCurrentPoint, onMouseLeave, currentPoint]\n    )\n\n    const handleMouseDown = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (onMouseDown) {\n                const point = getPointFromMouseEvent(event)\n                if (point) onMouseDown(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onMouseDown]\n    )\n\n    const handleMouseUp = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (onMouseUp) {\n                const point = getPointFromMouseEvent(event)\n                if (point) onMouseUp(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onMouseUp]\n    )\n\n    const handleClick = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (onClick) {\n                const point = getPointFromMouseEvent(event)\n                if (point) onClick(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onClick]\n    )\n\n    const handleDoubleClick = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (onDoubleClick) {\n                const point = getPointFromMouseEvent(event)\n                if (point) onDoubleClick(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onDoubleClick]\n    )\n\n    return (\n        <canvas\n            ref={mergeRefs<HTMLCanvasElement>(canvasEl, forwardedRef)}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n                cursor: isInteractive ? 'auto' : 'normal',\n            }}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n            onMouseDown={isInteractive ? handleMouseDown : undefined}\n            onMouseUp={isInteractive ? handleMouseUp : undefined}\n            onClick={isInteractive ? handleClick : undefined}\n            onDoubleClick={isInteractive ? handleDoubleClick : undefined}\n        />\n    )\n}\n\nexport const LineCanvas = forwardRef(\n    <Series extends LineSeries>(\n        { isInteractive, renderWrapper, theme, ...props }: LineCanvasProps<Series>,\n        ref: Ref<HTMLCanvasElement>\n    ) => (\n        <Container {...{ isInteractive, renderWrapper, theme }} animate={false}>\n            <InnerLineCanvas<Series> {...props} forwardedRef={ref} />\n        </Container>\n    )\n) as <Series extends LineSeries>(\n    props: LineCanvasProps<Series> & {\n        ref?: ForwardedRef<HTMLCanvasElement>\n    }\n) => ReactElement\n","import { forwardRef, Ref, ReactElement } from 'react'\nimport { ResponsiveWrapper } from '@nivo/core'\nimport { LineCanvasProps, LineSeries } from './types'\nimport { LineCanvas } from './LineCanvas'\n\nexport type ResponsiveLineCanvasProps<Series extends LineSeries> = Omit<\n    LineCanvasProps<Series>,\n    'width' | 'height'\n>\n\nfunction InnerResponsiveLineCanvas<Series extends LineSeries>(\n    props: ResponsiveLineCanvasProps<Series>,\n    ref: Ref<HTMLCanvasElement>\n) {\n    return (\n        <ResponsiveWrapper>\n            {({ width, height }: { width: number; height: number }) => (\n                <LineCanvas<Series> width={width} height={height} {...props} ref={ref} />\n            )}\n        </ResponsiveWrapper>\n    )\n}\n\nexport const ResponsiveLineCanvas = forwardRef<HTMLCanvasElement, ResponsiveLineCanvasProps<any>>(\n    InnerResponsiveLineCanvas\n) as <Series extends LineSeries>(\n    props: ResponsiveLineCanvasProps<Series> & {\n        ref?: Ref<HTMLCanvasElement>\n    }\n) => ReactElement\n","import { FunctionComponent, MouseEvent, TouchEvent, AriaAttributes } from 'react'\nimport { Line, Area } from 'd3-shape'\nimport {\n    Dimensions,\n    Box,\n    MotionProps,\n    CssMixBlendMode,\n    ValueFormat,\n    SvgDefsAndFill,\n    CartesianMarkerProps,\n    PropertyAccessor,\n    LineCurveFactoryId,\n    DotsItemSymbolComponent,\n} from '@nivo/core'\nimport { PartialTheme } from '@nivo/theming'\nimport { AxisProps, CanvasAxisProps } from '@nivo/axes'\nimport { InheritedColorConfig, OrdinalColorScaleConfig } from '@nivo/colors'\nimport { ScaleSpec, TicksSpec } from '@nivo/scales'\nimport { LegendProps } from '@nivo/legends'\nimport { CrosshairType } from '@nivo/tooltip'\n\nexport type AllowedSeriesId = string | number\n// `null` is allowed in the data to indicate a missing value.\nexport type AllowedValue = string | number | Date | null\nexport type LineSeries = {\n    id: AllowedSeriesId\n    data: readonly { x: AllowedValue; y: AllowedValue }[]\n}\n\nexport type InferSeriesId<T> = T extends { id: infer Id } ? Id : never\n\nexport type InferX<T> = T extends { data: ReadonlyArray<infer D> }\n    ? D extends { x: infer X }\n        ? X\n        : never\n    : never\nexport type InferY<T> = T extends { data: ReadonlyArray<infer D> }\n    ? D extends { y: infer Y }\n        ? Y\n        : never\n    : never\n\nexport type DefaultSeries = {\n    id: string\n    data: readonly {\n        x: string | null\n        y: number | null\n    }[]\n}\n\nexport interface ComputedDatum<Series extends LineSeries> {\n    data: Series['data'][number]\n    position: {\n        x: number\n        y: number\n    }\n}\n\nexport type ComputedSeries<Series extends LineSeries> = Omit<Series, 'data' | 'id'> & {\n    id: InferSeriesId<Series>\n    data: readonly ComputedDatum<Series>[]\n    color: string\n}\n\nexport interface Point<Series extends LineSeries> {\n    id: string\n    indexInSeries: number\n    absIndex: number\n    seriesIndex: number\n    seriesId: InferSeriesId<Series>\n    seriesColor: string\n    x: number\n    y: number\n    color: string\n    borderColor: string\n    data: Series['data'][number] & {\n        xFormatted: string\n        yFormatted: string\n    }\n}\n\nexport type PointColorContext<Series extends LineSeries> = {\n    series: ComputedSeries<Series>\n    point: Omit<Point<Series>, 'color' | 'borderColor'>\n}\n\nexport interface SliceData<Series extends LineSeries> {\n    id: string\n    x0: number\n    x: number\n    y0: number\n    y: number\n    width: number\n    height: number\n    points: readonly Point<Series>[]\n}\n\nexport type PointOrSliceData<Series extends LineSeries> = Point<Series> | SliceData<Series>\nexport function isPoint<Series extends LineSeries>(\n    data: PointOrSliceData<Series>\n): data is Point<Series> {\n    return (data as Point<Series>).seriesId !== undefined\n}\nexport function isSliceData<Series extends LineSeries>(\n    data: PointOrSliceData<Series>\n): data is SliceData<Series> {\n    return (data as SliceData<Series>).points !== undefined\n}\n\nexport interface DataProps<Series extends LineSeries> {\n    data: readonly Series[]\n}\n\nexport type LineGenerator = Line<{ x: number; y: number }>\nexport type AreaGenerator = Area<{ x: number; y: number }>\n\nexport interface PointTooltipProps<Series extends LineSeries> {\n    point: Point<Series>\n}\nexport type PointTooltipComponent<Series extends LineSeries> = FunctionComponent<\n    PointTooltipProps<Series>\n>\n\nexport interface SliceTooltipProps<Series extends LineSeries> {\n    axis: 'x' | 'y'\n    slice: SliceData<Series>\n}\nexport type SliceTooltipComponent<Series extends LineSeries> = FunctionComponent<\n    SliceTooltipProps<Series>\n>\n\nexport type PointOrSliceMouseHandler<Series extends LineSeries> = (\n    datum: Readonly<Point<Series>> | Readonly<SliceData<Series>>,\n    event: MouseEvent\n) => void\nexport type PointOrSliceTouchHandler<Series extends LineSeries> = (\n    datum: Readonly<Point<Series>> | Readonly<SliceData<Series>>,\n    event: TouchEvent\n) => void\n\nexport type LineLayerId =\n    | 'grid'\n    | 'markers'\n    | 'axes'\n    | 'areas'\n    | 'crosshair'\n    | 'lines'\n    | 'slices'\n    | 'points'\n    | 'mesh'\n    | 'legends'\n\nexport interface CommonCustomLayerProps<Series extends LineSeries> {\n    innerWidth: number\n    innerHeight: number\n    series: readonly ComputedSeries<Series>[]\n    points: readonly Point<Series>[]\n    xScale: (x: InferX<Series>) => number\n    yScale: (y: InferY<Series>) => number\n    lineGenerator: LineGenerator\n    areaGenerator: AreaGenerator\n    currentPoint: Point<Series> | null\n    setCurrentPoint: (point: Point<Series> | null) => void\n}\n\nexport type LineCustomSvgLayerProps<Series extends LineSeries> = Omit<\n    LineSvgPropsWithDefaults<Series>,\n    'xScale' | 'yScale'\n> &\n    CommonCustomLayerProps<Series> & {\n        slices: readonly SliceData<Series>[]\n        currentSlice: SliceData<Series> | null\n        setCurrentSlice: (slice: SliceData<Series> | null) => void\n    }\nexport type LineCustomSvgLayer<Series extends LineSeries> = FunctionComponent<\n    LineCustomSvgLayerProps<Series>\n>\nexport type LineSvgLayer<Series extends LineSeries> = LineLayerId | LineCustomSvgLayer<Series>\n\nexport type LineCustomCanvasLayerProps<Series extends LineSeries> = CommonCustomLayerProps<Series>\nexport type LineCustomCanvasLayer<Series extends LineSeries> = (\n    context: CanvasRenderingContext2D,\n    props: LineCustomCanvasLayerProps<Series>\n) => void\nexport type LineCanvasLayer<Series extends LineSeries> = LineLayerId | LineCustomCanvasLayer<Series>\n\nexport type CommonLineProps<Series extends LineSeries> = {\n    xScale: ScaleSpec\n    xFormat?: ValueFormat<InferX<Series>>\n    yScale: ScaleSpec\n    yFormat?: ValueFormat<InferY<Series>>\n    margin: Box\n    curve: LineCurveFactoryId\n    theme: PartialTheme\n    colors: OrdinalColorScaleConfig<Series>\n    lineWidth: number\n    enablePoints: boolean\n    pointSymbol?: DotsItemSymbolComponent<Point<Series>>\n    pointSize: number\n    pointColor: InheritedColorConfig<PointColorContext<Series>>\n    pointBorderWidth: number\n    pointBorderColor: InheritedColorConfig<Omit<Point<Series>, 'borderColor'>>\n    enableArea: boolean\n    areaBaselineValue: InferY<Series>\n    areaOpacity: number\n    enableGridX: boolean\n    gridXValues?: TicksSpec<InferX<Series>>\n    enableGridY: boolean\n    gridYValues?: TicksSpec<InferY<Series>>\n    legends: readonly LegendProps[]\n    isInteractive: boolean\n    debugMesh: boolean\n    onMouseEnter?: PointOrSliceMouseHandler<Series>\n    onMouseMove?: PointOrSliceMouseHandler<Series>\n    onMouseLeave?: PointOrSliceMouseHandler<Series>\n    onMouseDown?: PointOrSliceMouseHandler<Series>\n    onMouseUp?: PointOrSliceMouseHandler<Series>\n    onClick?: PointOrSliceMouseHandler<Series>\n    onDoubleClick?: PointOrSliceMouseHandler<Series>\n    onTouchStart?: PointOrSliceTouchHandler<Series>\n    onTouchMove?: PointOrSliceTouchHandler<Series>\n    onTouchEnd?: PointOrSliceTouchHandler<Series>\n    tooltip: PointTooltipComponent<Series>\n    sliceTooltip: SliceTooltipComponent<Series>\n    renderWrapper: boolean\n}\n\nexport interface LineSvgExtraProps<Series extends LineSeries> {\n    layers: readonly LineSvgLayer<Series>[]\n    enablePointLabel: boolean\n    pointLabel: PropertyAccessor<Point<Series>, string>\n    pointLabelYOffset?: number\n    areaBlendMode: CssMixBlendMode\n    axisTop?: AxisProps | null\n    axisRight?: AxisProps | null\n    axisBottom?: AxisProps | null\n    axisLeft?: AxisProps | null\n    useMesh: boolean\n    enableSlices: 'x' | 'y' | false\n    debugSlices: boolean\n    enableCrosshair: boolean\n    crosshairType: CrosshairType\n    enableTouchCrosshair: boolean\n    markers?: readonly CartesianMarkerProps[]\n    initialHiddenIds: readonly InferSeriesId<Series>[]\n    animate: boolean\n    motionConfig: MotionProps['motionConfig']\n    role: string\n    ariaLabel?: AriaAttributes['aria-label']\n    ariaLabelledBy?: AriaAttributes['aria-labelledby']\n    ariaDescribedBy?: AriaAttributes['aria-describedby']\n    isFocusable: boolean\n    pointAriaLabel?: (point: Point<Series>) => AriaAttributes['aria-label']\n    pointAriaLabelledBy?: (point: Point<Series>) => AriaAttributes['aria-labelledby']\n    pointAriaDescribedBy?: (point: Point<Series>) => AriaAttributes['aria-describedby']\n    pointAriaHidden?: (point: Point<Series>) => AriaAttributes['aria-hidden']\n    pointAriaDisabled?: (point: Point<Series>) => AriaAttributes['aria-disabled']\n}\nexport type LineSvgProps<Series extends LineSeries> = DataProps<Series> &\n    Dimensions &\n    Partial<CommonLineProps<Series>> &\n    Partial<LineSvgExtraProps<Series>> &\n    SvgDefsAndFill<any>\nexport type LineSvgPropsWithDefaults<Series extends LineSeries> = DataProps<Series> &\n    Dimensions &\n    CommonLineProps<Series> &\n    LineSvgExtraProps<Series> &\n    SvgDefsAndFill<any>\n\nexport interface LineCanvasExtraProps<Series extends LineSeries> {\n    layers: readonly LineCanvasLayer<Series>[]\n    pixelRatio: number\n    axisTop?: CanvasAxisProps | null\n    axisRight?: CanvasAxisProps | null\n    axisBottom?: CanvasAxisProps | null\n    axisLeft?: CanvasAxisProps | null\n}\nexport type LineCanvasProps<Series extends LineSeries> = DataProps<Series> &\n    Dimensions &\n    Partial<CommonLineProps<Series>> &\n    Partial<LineCanvasExtraProps<Series>>\nexport type LineCanvasPropsWithDefaults<Series extends LineSeries> = DataProps<Series> &\n    Dimensions &\n    CommonLineProps<Series> &\n    LineCanvasExtraProps<Series>\n"],"names":["commonDefaultProps","xScale","type","yScale","min","max","curve","colors","scheme","lineWidth","layers","enablePoints","pointSize","pointColor","from","pointBorderWidth","pointBorderColor","theme","enableArea","areaBaselineValue","areaOpacity","enableGridX","enableGridY","legends","isInteractive","tooltip","memo","_ref","point","_jsx","BasicTooltip","id","_jsxs","children","data","xFormatted","yFormatted","enableChip","color","seriesColor","sliceTooltip","slice","axis","useTheme","otherAxis","TableTooltip","rows","points","map","Chip","style","chip","seriesId","tableCellValue","debugMesh","renderWrapper","svgDefaultProps","_extends","defs","fill","enablePointLabel","pointLabel","areaBlendMode","axisBottom","axisLeft","useMesh","enableSlices","debugSlices","enableCrosshair","crosshairType","enableTouchCrosshair","initialHiddenIds","animate","motionConfig","role","isFocusable","canvasDefaultProps","pixelRatio","window","_window$devicePixelRa","devicePixelRatio","useLineGenerator","useMemo","line","defined","d","x","y","curveFromProp","useAreaGenerator","area","y1","y0","useSlices","_ref3","componentId","width","height","Map","forEach","has","get","push","set","Array","entries","sort","a","b","_ref4","i","slices","x0","sliceWidth","slicePoints","prevSlice","nextSlice","reverse","_ref5","sliceHeight","LINE_UNIQUE_ID_PREFIX","useLine","_ref6","_ref6$xScale","xScaleSpec","xFormat","_ref6$yScale","yScaleSpec","yFormat","_ref6$colors","_ref6$curve","_ref6$areaBaselineVal","_ref6$pointColor","_ref6$pointBorderColo","_ref6$enableSlices","_ref6$initialHiddenId","useState","uniqueId","formatX","useValueFormatter","formatY","getColor","useOrdinalColorScale","getPointColor","useInheritedColor","getPointBorderColor","_useState2","hiddenIds","setHiddenIds","_useMemo","computeXYScalesForSeries","filter","item","indexOf","rawSeries","series","_useMemo2","dataWithColor","seriesItem","label","datum","find","Boolean","legendData","hidden","toggleSeries","useCallback","state","concat","_ref2","reduce","acc","seriesIndex","position","indexInSeries","absIndex","length","borderColor","usePoints","lineGenerator","areaGenerator","AreaPath","path","_useMotionConfig","useMotionConfig","springConfig","config","animatedPath","useAnimatedPath","animatedProps","useSpring","immediate","animated","fillOpacity","strokeWidth","mixBlendMode","Areas","reversedSeries","LinesItem","thickness","stroke","Lines","_Fragment","SlicesItem","debug","isCurrent","setCurrent","onMouseEnter","onMouseMove","onMouseLeave","onMouseDown","onMouseUp","onClick","onDoubleClick","onTouchStart","onTouchMove","onTouchEnd","_useTooltip","useTooltip","showTooltipFromEvent","hideTooltip","handleMouseEnter","event","createElement","handleMouseMove","handleMouseLeave","handleMouseDown","handleMouseUp","handleClick","handleDoubleClick","handeOnTouchStart","handeOnTouchMove","touchPoint","touches","touchingElement","document","elementFromPoint","clientX","clientY","touchingSliceId","getAttribute","handleOnTouchEnd","strokeOpacity","Slices","current","Points","symbol","size","borderWidth","enableLabel","labelYOffset","setCurrentPoint","margin","ariaLabel","ariaLabelledBy","ariaDescribedBy","ariaHidden","ariaDisabled","getLabel","getLabelGenerator","showTooltipAt","mappedPoints","undefined","onFocus","left","top","onBlur","DotsItem","testId","Mesh","handleTouchStart","handleTouchMove","handleTouchEnd","BaseMesh","nodes","InnerLine","props","_props$xScale","_props$yScale","_props$curve","partialMargin","_props$colors","_props$lineWidth","_props$layers","_props$enableArea","_props$areaBaselineVa","_props$areaOpacity","_props$areaBlendMode","_props$enablePoints","pointSymbol","_props$pointSize","_props$pointColor","_props$pointBorderWid","_props$pointBorderCol","_props$enablePointLab","_props$pointLabel","pointLabelYOffset","_props$enableGridX","gridXValues","_props$enableGridY","gridYValues","axisTop","axisRight","_props$axisBottom","_props$axisLeft","_props$defs","_props$fill","markers","_props$legends","_props$isInteractive","_props$useMesh","_props$debugMesh","_props$tooltip","_props$enableSlices","_props$debugSlices","_props$sliceTooltip","_props$enableCrosshai","_props$crosshairType","_props$enableTouchCro","_props$role","_props$isFocusable","pointAriaLabel","pointAriaLabelledBy","pointAriaDescribedBy","pointAriaHidden","pointAriaDisabled","_props$initialHiddenI","_useDimensions","useDimensions","innerWidth","innerHeight","outerWidth","outerHeight","_useLine","_useState","currentPoint","currentSlice","setCurrentSlice","layerById","grid","axes","areas","crosshair","lines","mesh","includes","Grid","xValues","yValues","isArray","CartesianMarkers","Axes","right","bottom","Fragment","legend","BoxLegendSvg","containerWidth","containerHeight","toggleSerie","boundDefs","bindDefs","Crosshair","customLayerProps","SvgWrapper","layer","Line","_ref$isInteractive","_ref$animate","_ref$motionConfig","otherProps","_objectWithoutPropertiesLoose","_excluded","Container","ResponsiveLine","ResponsiveWrapper","InnerLineCanvas","_ref$pixelRatio","_ref$xScale","_ref$yScale","_ref$curve","_ref$layers","_ref$colors","_ref$lineWidth","_ref$enableArea","_ref$areaBaselineValu","_ref$areaOpacity","_ref$enablePoints","_ref$pointSize","_ref$pointColor","_ref$pointBorderWidth","_ref$pointBorderColor","_ref$enableGridX","_ref$enableGridY","_ref$axisBottom","_ref$axisLeft","_ref$legends","_ref$debugMesh","_ref$tooltip","forwardedRef","canvasEl","useRef","_useVoronoiMesh","useVoronoiMesh","delaunay","voronoi","useEffect","ctx","getContext","scale","fillStyle","background","fillRect","translate","_theme$grid$line$stro","gridLineWidth","strokeStyle","renderGridLinesToCanvas","values","renderAxesToCanvas","save","globalAlpha","context","beginPath","restore","arc","Math","PI","renderVoronoiToCanvas","renderVoronoiCellToCanvas","serie","renderLegendToCanvas","getPointFromMouseEvent","_getRelativeCursor","getRelativeCursor","isCursorInRect","pointIndex","handleMouseHover","ref","mergeRefs","cursor","LineCanvas","forwardRef","ResponsiveLineCanvas","isPoint","isSliceData"],"mappings":"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"}